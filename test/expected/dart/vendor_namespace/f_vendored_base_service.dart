// Autogenerated by Frugal Compiler (3.12.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



// ignore_for_file: unused_import
// ignore_for_file: unused_field
import 'dart:async';
import 'dart:typed_data' show Uint8List;

import 'package:collection/collection.dart';
import 'package:logging/logging.dart' as logging;
import 'package:thrift/thrift.dart' as thrift;
import 'package:frugal/frugal.dart' as frugal;
import 'package:w_common/disposable.dart' as disposable;

import 'package:vendor_namespace/vendor_namespace.dart' as t_vendor_namespace;


abstract class FVendoredBase {}

FVendoredBaseClient fVendoredBaseClientFactory(frugal.FServiceProvider provider, {List<frugal.Middleware> middleware}) =>
    FVendoredBaseClient(provider, middleware);

class FVendoredBaseClient extends disposable.Disposable implements FVendoredBase {
  static final logging.Logger _frugalLog = logging.Logger('VendoredBase');
  Map<String, frugal.FMethod> _methods;

  FVendoredBaseClient(frugal.FServiceProvider provider, [List<frugal.Middleware> middleware])
      : this._provider = provider {
    _transport = provider.transport;
    _protocolFactory = provider.protocolFactory;
    var combined = middleware ?? [];
    combined.addAll(provider.middleware);
    this._methods = {};
  }

  frugal.FServiceProvider _provider;
  frugal.FTransport _transport;
  frugal.FProtocolFactory _protocolFactory;

  @override
  Future<Null> onDispose() async {
    if (_provider is disposable.Disposable && !_provider.isOrWillBeDisposed)  {
      return _provider.dispose();
    }
    return null;
  }

  
Uint8List _prepareMessage(frugal.FContext ctx, String method, thrift.TBase args, int kind) {
    final memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    final oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage(method, kind, 0));
    args.write(oprot);
    oprot.writeMessageEnd();
    return memoryBuffer.writeBytes;
  }
  
void _processReply(frugal.FContext ctx, thrift.TBase result, thrift.TTransport response) {
    final iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    final msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      final error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    result.read(iprot);
    iprot.readMessageEnd();
  }
}

