// Autogenerated by Frugal Compiler (0.0.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

library valid.src.f_foo_scope;

import 'dart:async';

import 'package:thrift/thrift.dart' as thrift;
import 'package:frugal/frugal.dart' as frugal;

import 'package:valid/valid.dart' as t_valid;


const String delimiter = '.';

/// And this is a scope docstring.
class FooPublisher {
  frugal.FScopeTransport fTransport;
  frugal.FProtocol fProtocol;
  FooPublisher(frugal.FScopeProvider provider) {
    var tp = provider.newTransportProtocol();
    fTransport = tp.fTransport;
    fProtocol = tp.fProtocol;
  }

  Future open() {
    return fTransport.open();
  }

  Future close() {
    return fTransport.close();
  }

  /// This is an operation docstring.
  Future publishFoo(frugal.FContext ctx, String baz, t_thing.Thing req) async {
    var op = "Foo";
    var prefix = "foo.bar.${baz}.qux.";
    var topic = "${prefix}Foo${delimiter}${op}";
    fTransport.setTopic(topic);
    var oprot = fProtocol;
    var msg = new thrift.TMessage(op, thrift.TMessageType.CALL, 0);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(msg);
    req.write(oprot);
    oprot.writeMessageEnd();
    await oprot.transport.flush();
  }


  Future publishBar(frugal.FContext ctx, String baz, t_stuff.Stuff req) async {
    var op = "Bar";
    var prefix = "foo.bar.${baz}.qux.";
    var topic = "${prefix}Foo${delimiter}${op}";
    fTransport.setTopic(topic);
    var oprot = fProtocol;
    var msg = new thrift.TMessage(op, thrift.TMessageType.CALL, 0);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(msg);
    req.write(oprot);
    oprot.writeMessageEnd();
    await oprot.transport.flush();
  }
}


/// And this is a scope docstring.
class FooSubscriber {
  final frugal.FScopeProvider provider;

  FooSubscriber(this.provider) {}

  /// This is an operation docstring.
  Future<frugal.FSubscription> subscribeFoo(String baz, dynamic onThing(frugal.FContext ctx, t_thing.Thing req)) async {
    var op = "Foo";
    var prefix = "foo.bar.${baz}.qux.";
    var topic = "${prefix}Foo${delimiter}${op}";
    var tp = provider.newTransportProtocol();
    await tp.fTransport.subscribe(topic);
    tp.fTransport.signalRead.listen((_) {
      var ctx = tp.fProtocol.readRequestHeader();
      onThing(ctx, _recvFoo(op, tp.fProtocol));
    });
    var sub = new frugal.FSubscription(topic, tp.fTransport);
    tp.fTransport.error.listen((Error e) {;
      sub.signal(e);
    });
    return sub;
  }

  t_thing.Thing _recvFoo(String op, frugal.FProtocol iprot) {
    var tMsg = iprot.readMessageBegin();
    if (tMsg.name != op) {
      thrift.TProtocolUtil.skip(iprot, thrift.TType.STRUCT);
      iprot.readMessageEnd();
      throw new thrift.TApplicationError(
      thrift.TApplicationErrorType.UNKNOWN_METHOD, tMsg.name);
    }
    var req = new t_thing.Thing();
    req.read(iprot);
    iprot.readMessageEnd();
    return req;
  }


  Future<frugal.FSubscription> subscribeBar(String baz, dynamic onStuff(frugal.FContext ctx, t_stuff.Stuff req)) async {
    var op = "Bar";
    var prefix = "foo.bar.${baz}.qux.";
    var topic = "${prefix}Foo${delimiter}${op}";
    var tp = provider.newTransportProtocol();
    await tp.fTransport.subscribe(topic);
    tp.fTransport.signalRead.listen((_) {
      var ctx = tp.fProtocol.readRequestHeader();
      onStuff(ctx, _recvBar(op, tp.fProtocol));
    });
    var sub = new frugal.FSubscription(topic, tp.fTransport);
    tp.fTransport.error.listen((Error e) {;
      sub.signal(e);
    });
    return sub;
  }

  t_stuff.Stuff _recvBar(String op, frugal.FProtocol iprot) {
    var tMsg = iprot.readMessageBegin();
    if (tMsg.name != op) {
      thrift.TProtocolUtil.skip(iprot, thrift.TType.STRUCT);
      iprot.readMessageEnd();
      throw new thrift.TApplicationError(
      thrift.TApplicationErrorType.UNKNOWN_METHOD, tMsg.name);
    }
    var req = new t_stuff.Stuff();
    req.read(iprot);
    iprot.readMessageEnd();
    return req;
  }
}

