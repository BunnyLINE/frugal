// Autogenerated by Frugal Compiler (2.14.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package type_test

import (
	"bytes"
	"fmt"

	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/Sirupsen/logrus"
	"github.com/Workiva/frugal/lib/go"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal
var _ = logrus.DebugLevel

type FTypeTest interface {
	GetBoolArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetByteArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetI16Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetI32Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetI64Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetDoubleArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetBinaryArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
	GetStringArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error)
}

type FTypeTestClient struct {
	transport       frugal.FTransport
	protocolFactory *frugal.FProtocolFactory
	methods         map[string]*frugal.Method
}

func NewFTypeTestClient(provider *frugal.FServiceProvider, middleware ...frugal.ServiceMiddleware) *FTypeTestClient {
	methods := make(map[string]*frugal.Method)
	client := &FTypeTestClient{
		transport:       provider.GetTransport(),
		protocolFactory: provider.GetProtocolFactory(),
		methods:         methods,
	}
	middleware = append(middleware, provider.GetMiddleware()...)
	methods["getBoolArgument"] = frugal.NewMethod(client, client.getBoolArgument, "getBoolArgument", middleware)
	methods["getByteArgument"] = frugal.NewMethod(client, client.getByteArgument, "getByteArgument", middleware)
	methods["getI16Argument"] = frugal.NewMethod(client, client.getI16Argument, "getI16Argument", middleware)
	methods["getI32Argument"] = frugal.NewMethod(client, client.getI32Argument, "getI32Argument", middleware)
	methods["getI64Argument"] = frugal.NewMethod(client, client.getI64Argument, "getI64Argument", middleware)
	methods["getDoubleArgument"] = frugal.NewMethod(client, client.getDoubleArgument, "getDoubleArgument", middleware)
	methods["getBinaryArgument"] = frugal.NewMethod(client, client.getBinaryArgument, "getBinaryArgument", middleware)
	methods["getStringArgument"] = frugal.NewMethod(client, client.getStringArgument, "getStringArgument", middleware)
	return client
}

func (f *FTypeTestClient) GetBoolArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getBoolArgument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getBoolArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getBoolArgument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetBoolArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getBoolArgument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getBoolArgument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getBoolArgument failed: invalid message type")
		return
	}
	result := TypeTestGetBoolArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetByteArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getByteArgument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getByteArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getByteArgument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetByteArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getByteArgument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getByteArgument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getByteArgument failed: invalid message type")
		return
	}
	result := TypeTestGetByteArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetI16Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getI16Argument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getI16Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getI16Argument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetI16ArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getI16Argument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getI16Argument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getI16Argument failed: invalid message type")
		return
	}
	result := TypeTestGetI16ArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetI32Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getI32Argument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getI32Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getI32Argument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetI32ArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getI32Argument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getI32Argument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getI32Argument failed: invalid message type")
		return
	}
	result := TypeTestGetI32ArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetI64Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getI64Argument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getI64Argument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getI64Argument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetI64ArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getI64Argument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getI64Argument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getI64Argument failed: invalid message type")
		return
	}
	result := TypeTestGetI64ArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetDoubleArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getDoubleArgument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getDoubleArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getDoubleArgument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetDoubleArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getDoubleArgument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getDoubleArgument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getDoubleArgument failed: invalid message type")
		return
	}
	result := TypeTestGetDoubleArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetBinaryArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getBinaryArgument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getBinaryArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getBinaryArgument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetBinaryArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getBinaryArgument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getBinaryArgument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getBinaryArgument failed: invalid message type")
		return
	}
	result := TypeTestGetBinaryArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

func (f *FTypeTestClient) GetStringArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	ret := f.methods["getStringArgument"].Invoke([]interface{}{ctx, request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[0] != nil {
		r = ret[0].(*BaseType)
	}
	if ret[1] != nil {
		err = ret[1].(error)
	}
	return r, err
}

func (f *FTypeTestClient) getStringArgument(ctx frugal.FContext, request *BaseType) (r *BaseType, err error) {
	buffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())
	oprot := f.protocolFactory.GetProtocol(buffer)
	if err = oprot.WriteRequestHeader(ctx); err != nil {
		return
	}
	if err = oprot.WriteMessageBegin("getStringArgument", thrift.CALL, 0); err != nil {
		return
	}
	args := TypeTestGetStringArgumentArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	if err = oprot.Flush(); err != nil {
		return
	}
	var resultTransport thrift.TTransport
	resultTransport, err = f.transport.Request(ctx, buffer.Bytes())
	if err != nil {
		return
	}
	iprot := f.protocolFactory.GetProtocol(resultTransport)
	if err = iprot.ReadResponseHeader(ctx); err != nil {
		return
	}
	method, mTypeId, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getStringArgument" {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, "getStringArgument failed: wrong method name")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, "Unknown Exception")
		var error1 thrift.TApplicationException
		error1, err = error0.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		if error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {
			err = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())
			return
		}
		err = error1
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, "getStringArgument failed: invalid message type")
		return
	}
	result := TypeTestGetStringArgumentResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	r = result.GetSuccess()
	return
}

type FTypeTestProcessor struct {
	*frugal.FBaseProcessor
}

func NewFTypeTestProcessor(handler FTypeTest, middleware ...frugal.ServiceMiddleware) *FTypeTestProcessor {
	p := &FTypeTestProcessor{frugal.NewFBaseProcessor()}
	p.AddToProcessorMap("getBoolArgument", &typetestFGetBoolArgument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetBoolArgument, "GetBoolArgument", middleware))})
	p.AddToAnnotationsMap("getBoolArgument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{boolTest}/",
	})
	p.AddToProcessorMap("getByteArgument", &typetestFGetByteArgument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetByteArgument, "GetByteArgument", middleware))})
	p.AddToAnnotationsMap("getByteArgument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{byteTest}/",
	})
	p.AddToProcessorMap("getI16Argument", &typetestFGetI16Argument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetI16Argument, "GetI16Argument", middleware))})
	p.AddToAnnotationsMap("getI16Argument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{i16Test}/",
	})
	p.AddToProcessorMap("getI32Argument", &typetestFGetI32Argument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetI32Argument, "GetI32Argument", middleware))})
	p.AddToAnnotationsMap("getI32Argument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{i32Test}/",
	})
	p.AddToProcessorMap("getI64Argument", &typetestFGetI64Argument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetI64Argument, "GetI64Argument", middleware))})
	p.AddToAnnotationsMap("getI64Argument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{i64Test}/",
	})
	p.AddToProcessorMap("getDoubleArgument", &typetestFGetDoubleArgument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetDoubleArgument, "GetDoubleArgument", middleware))})
	p.AddToAnnotationsMap("getDoubleArgument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{doubleTest}/",
	})
	p.AddToProcessorMap("getBinaryArgument", &typetestFGetBinaryArgument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetBinaryArgument, "GetBinaryArgument", middleware))})
	p.AddToAnnotationsMap("getBinaryArgument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{binaryTest}/",
	})
	p.AddToProcessorMap("getStringArgument", &typetestFGetStringArgument{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.GetStringArgument, "GetStringArgument", middleware))})
	p.AddToAnnotationsMap("getStringArgument", map[string]string{
		"http.method":       "get",
		"http.pathTemplate": "/{stringTest}/",
	})
	return p
}

type typetestFGetBoolArgument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetBoolArgument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetBoolArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getBoolArgument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetBoolArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getBoolArgument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getBoolArgument", "Internal error processing getBoolArgument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBoolArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getBoolArgument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBoolArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBoolArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBoolArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBoolArgument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetByteArgument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetByteArgument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetByteArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getByteArgument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetByteArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getByteArgument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getByteArgument", "Internal error processing getByteArgument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getByteArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getByteArgument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getByteArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getByteArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getByteArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getByteArgument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetI16Argument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetI16Argument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetI16ArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getI16Argument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetI16ArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getI16Argument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getI16Argument", "Internal error processing getI16Argument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI16Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getI16Argument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI16Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI16Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI16Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI16Argument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetI32Argument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetI32Argument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetI32ArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getI32Argument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetI32ArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getI32Argument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getI32Argument", "Internal error processing getI32Argument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI32Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getI32Argument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI32Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI32Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI32Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI32Argument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetI64Argument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetI64Argument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetI64ArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getI64Argument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetI64ArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getI64Argument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getI64Argument", "Internal error processing getI64Argument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI64Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getI64Argument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI64Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI64Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI64Argument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getI64Argument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetDoubleArgument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetDoubleArgument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetDoubleArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getDoubleArgument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetDoubleArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getDoubleArgument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getDoubleArgument", "Internal error processing getDoubleArgument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getDoubleArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getDoubleArgument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getDoubleArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getDoubleArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getDoubleArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getDoubleArgument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetBinaryArgument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetBinaryArgument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetBinaryArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getBinaryArgument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetBinaryArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getBinaryArgument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getBinaryArgument", "Internal error processing getBinaryArgument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBinaryArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getBinaryArgument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBinaryArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBinaryArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBinaryArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getBinaryArgument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type typetestFGetStringArgument struct {
	*frugal.FBaseProcessorFunction
}

func (p *typetestFGetStringArgument) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := TypeTestGetStringArgumentArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.GetWriteMutex().Lock()
		err = typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, "getStringArgument", err.Error())
		p.GetWriteMutex().Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := TypeTestGetStringArgumentResult{}
	var err2 error
	ret := p.InvokeMethod([]interface{}{ctx, args.Request})
	if len(ret) != 2 {
		panic(fmt.Sprintf("Middleware returned %d arguments, expected 2", len(ret)))
	}
	if ret[1] != nil {
		err2 = ret[1].(error)
	}
	if err2 != nil {
		if err3, ok := err2.(thrift.TApplicationException); ok {
			p.GetWriteMutex().Lock()
			oprot.WriteResponseHeader(ctx)
			oprot.WriteMessageBegin("getStringArgument", thrift.EXCEPTION, 0)
			err3.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			p.GetWriteMutex().Unlock()
			return nil
		}
		p.GetWriteMutex().Lock()
		err2 := typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, "getStringArgument", "Internal error processing getStringArgument: "+err2.Error())
		p.GetWriteMutex().Unlock()
		return err2
	} else {
		var retval *BaseType = ret[0].(*BaseType)
		result.Success = retval
	}
	p.GetWriteMutex().Lock()
	defer p.GetWriteMutex().Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getStringArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("getStringArgument", thrift.REPLY, 0); err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getStringArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getStringArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getStringArgument", err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if frugal.IsErrTooLarge(err2) {
			typetestWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, "getStringArgument", err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

func typetestWriteApplicationError(ctx frugal.FContext, oprot *frugal.FProtocol, type_ int32, method, message string) error {
	x := thrift.NewTApplicationException(type_, message)
	oprot.WriteResponseHeader(ctx)
	oprot.WriteMessageBegin(method, thrift.EXCEPTION, 0)
	x.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return x
}

type TypeTestGetBoolArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetBoolArgumentArgs() *TypeTestGetBoolArgumentArgs {
	return &TypeTestGetBoolArgumentArgs{}
}

var TypeTestGetBoolArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetBoolArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetBoolArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetBoolArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetBoolArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBoolArgument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetBoolArgumentArgs(%+v)", *p)
}

type TypeTestGetBoolArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetBoolArgumentResult() *TypeTestGetBoolArgumentResult {
	return &TypeTestGetBoolArgumentResult{}
}

var TypeTestGetBoolArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetBoolArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetBoolArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetBoolArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetBoolArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBoolArgument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetBoolArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetBoolArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetBoolArgumentResult(%+v)", *p)
}

type TypeTestGetByteArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetByteArgumentArgs() *TypeTestGetByteArgumentArgs {
	return &TypeTestGetByteArgumentArgs{}
}

var TypeTestGetByteArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetByteArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetByteArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetByteArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetByteArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getByteArgument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetByteArgumentArgs(%+v)", *p)
}

type TypeTestGetByteArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetByteArgumentResult() *TypeTestGetByteArgumentResult {
	return &TypeTestGetByteArgumentResult{}
}

var TypeTestGetByteArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetByteArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetByteArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetByteArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetByteArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getByteArgument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetByteArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetByteArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetByteArgumentResult(%+v)", *p)
}

type TypeTestGetI16ArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetI16ArgumentArgs() *TypeTestGetI16ArgumentArgs {
	return &TypeTestGetI16ArgumentArgs{}
}

var TypeTestGetI16ArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetI16ArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetI16ArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetI16ArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetI16ArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI16Argument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI16ArgumentArgs(%+v)", *p)
}

type TypeTestGetI16ArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetI16ArgumentResult() *TypeTestGetI16ArgumentResult {
	return &TypeTestGetI16ArgumentResult{}
}

var TypeTestGetI16ArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetI16ArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetI16ArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetI16ArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetI16ArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI16Argument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI16ArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetI16ArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI16ArgumentResult(%+v)", *p)
}

type TypeTestGetI32ArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetI32ArgumentArgs() *TypeTestGetI32ArgumentArgs {
	return &TypeTestGetI32ArgumentArgs{}
}

var TypeTestGetI32ArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetI32ArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetI32ArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetI32ArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetI32ArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI32Argument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI32ArgumentArgs(%+v)", *p)
}

type TypeTestGetI32ArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetI32ArgumentResult() *TypeTestGetI32ArgumentResult {
	return &TypeTestGetI32ArgumentResult{}
}

var TypeTestGetI32ArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetI32ArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetI32ArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetI32ArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetI32ArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI32Argument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI32ArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetI32ArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI32ArgumentResult(%+v)", *p)
}

type TypeTestGetI64ArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetI64ArgumentArgs() *TypeTestGetI64ArgumentArgs {
	return &TypeTestGetI64ArgumentArgs{}
}

var TypeTestGetI64ArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetI64ArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetI64ArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetI64ArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetI64ArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI64Argument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI64ArgumentArgs(%+v)", *p)
}

type TypeTestGetI64ArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetI64ArgumentResult() *TypeTestGetI64ArgumentResult {
	return &TypeTestGetI64ArgumentResult{}
}

var TypeTestGetI64ArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetI64ArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetI64ArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetI64ArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetI64ArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getI64Argument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetI64ArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetI64ArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetI64ArgumentResult(%+v)", *p)
}

type TypeTestGetDoubleArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetDoubleArgumentArgs() *TypeTestGetDoubleArgumentArgs {
	return &TypeTestGetDoubleArgumentArgs{}
}

var TypeTestGetDoubleArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetDoubleArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetDoubleArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetDoubleArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetDoubleArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDoubleArgument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetDoubleArgumentArgs(%+v)", *p)
}

type TypeTestGetDoubleArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetDoubleArgumentResult() *TypeTestGetDoubleArgumentResult {
	return &TypeTestGetDoubleArgumentResult{}
}

var TypeTestGetDoubleArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetDoubleArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetDoubleArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetDoubleArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetDoubleArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDoubleArgument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetDoubleArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetDoubleArgumentResult(%+v)", *p)
}

type TypeTestGetBinaryArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetBinaryArgumentArgs() *TypeTestGetBinaryArgumentArgs {
	return &TypeTestGetBinaryArgumentArgs{}
}

var TypeTestGetBinaryArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetBinaryArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetBinaryArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetBinaryArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetBinaryArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBinaryArgument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetBinaryArgumentArgs(%+v)", *p)
}

type TypeTestGetBinaryArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetBinaryArgumentResult() *TypeTestGetBinaryArgumentResult {
	return &TypeTestGetBinaryArgumentResult{}
}

var TypeTestGetBinaryArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetBinaryArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetBinaryArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetBinaryArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetBinaryArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBinaryArgument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetBinaryArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetBinaryArgumentResult(%+v)", *p)
}

type TypeTestGetStringArgumentArgs struct {
	Request *BaseType `thrift:"request,1" db:"request" json:"request"`
}

func NewTypeTestGetStringArgumentArgs() *TypeTestGetStringArgumentArgs {
	return &TypeTestGetStringArgumentArgs{}
}

var TypeTestGetStringArgumentArgs_Request_DEFAULT *BaseType

func (p *TypeTestGetStringArgumentArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TypeTestGetStringArgumentArgs) GetRequest() *BaseType {
	if !p.IsSetRequest() {
		return TypeTestGetStringArgumentArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *TypeTestGetStringArgumentArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = NewBaseType()
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getStringArgument_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentArgs) writeField1(oprot thrift.TProtocol) error {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetStringArgumentArgs(%+v)", *p)
}

type TypeTestGetStringArgumentResult struct {
	Success *BaseType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTypeTestGetStringArgumentResult() *TypeTestGetStringArgumentResult {
	return &TypeTestGetStringArgumentResult{}
}

var TypeTestGetStringArgumentResult_Success_DEFAULT *BaseType

func (p *TypeTestGetStringArgumentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TypeTestGetStringArgumentResult) GetSuccess() *BaseType {
	if !p.IsSetSuccess() {
		return TypeTestGetStringArgumentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TypeTestGetStringArgumentResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = NewBaseType()
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getStringArgument_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TypeTestGetStringArgumentResult) writeField0(oprot thrift.TProtocol) error {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return nil
}

func (p *TypeTestGetStringArgumentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TypeTestGetStringArgumentResult(%+v)", *p)
}
