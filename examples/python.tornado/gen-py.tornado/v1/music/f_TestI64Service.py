#
# Autogenerated by Frugal Compiler (3.4.10)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from datetime import timedelta
from threading import Lock

import sys
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.middleware import Method
from frugal.tornado.processor import FBaseProcessor
from frugal.tornado.processor import FProcessorFunction
from frugal.transport import TMemoryOutputBuffer
from frugal.util.deprecate import deprecated
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException
from tornado import gen
from tornado.concurrent import Future

from .ttypes import *


class Iface(object):

    def test(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: TestI64
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()
        middleware += provider.get_middleware()
        self._methods = {
            'test': Method(self._test, middleware),
        }

    def test(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: TestI64
        """
        return self._methods['test']([ctx, thing])

    @gen.coroutine
    def _test(self, ctx, thing):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('test', TMessageType.CALL, 0)
        args = test_args()
        args.thing = thing
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = test_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "test failed: unknown result")

class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('test', _test(Method(handler.test, middleware), self.get_write_lock()))


class _test(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_test, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = test_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = test_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.thing]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "test", exception=ex)
                return
        except Exception as e:
            # We need to store off the current exception information as `self._lock.acquire()` appears to clear the current exc_info
            exc_info = sys.exc_info()
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "test", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message="Internal error processing {}: {}".format("test", e.message))
            raise exc_info[0], exc_info[1], exc_info[2]
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('test', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "test", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class test_args(object):
    """
    Attributes:
     - thing
    """
    def __init__(self, thing=None):
        self.thing = thing

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.thing = TestI64()
                    self.thing.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('test_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.STRUCT, 1)
            self.thing.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.thing))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class test_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TestI64()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('test_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

