package golang

import (
	"fmt"
	"os"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	suffix           = "go"
	defaultOutputDir = "gen-go"
)

type Generator struct {
	*generator.BaseGenerator
}

func NewGenerator() generator.OOGenerator {
	return &Generator{&generator.BaseGenerator{}}
}

func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

func (g *Generator) GenerateFile(name, outputDir string, namespaces []*parser.Namespace) (*os.File, error) {
	return g.CreateFile(name, outputDir, suffix, namespaces)
}

func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		"// Autogenerated by Frugal Compiler (%s)\n"+
			"// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING",
		generator.Version)

	_, err := file.WriteString(comment)
	return err
}

func (g *Generator) GeneratePackage(file *os.File, name, outputDir string) error {
	_, err := file.WriteString(fmt.Sprintf("package %s", name))
	return err
}

func (g *Generator) GenerateImports(file *os.File) error {
	imports := "import (\n"
	imports += "\t\"fmt\"\n"
	imports += "\t\"log\"\n\n"
	imports += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	imports += "\t\"github.com/Workiva/frugal/lib/go\"\n"
	imports += ")"
	_, err := file.WriteString(imports)
	return err
}

func (g *Generator) GenerateConstants(file *os.File, name string) error {
	constants := "const (\n"
	constants += "\ttopicBase = \"" + name + "\"\n"
	constants += "\tdelimiter = \".\"\n"
	constants += ")"
	_, err := file.WriteString(constants)
	return err
}

func (g *Generator) GenerateInterfaces(file *os.File, namespaces []*parser.Namespace) error {
	var (
		interfaces = ""
		prefix     = ""
	)
	for _, namespace := range namespaces {
		interfaces += prefix
		prefix = "\n\n"
		interfaces += fmt.Sprintf("type %sPubSub interface {\n", namespace.Name)
		for _, op := range namespace.Operations {
			interfaces += fmt.Sprintf("\t%s(*%s) error\n", op.Name, op.Param)
		}
		interfaces += "}"
	}
	_, err := file.WriteString(interfaces)
	return err
}

func (g *Generator) GeneratePublishers(file *os.File, namespaces []*parser.Namespace) error {
	publishers := ""
	for _, namespace := range namespaces {
		publishers = g.generatePublisher(publishers, namespace)
	}
	_, err := file.WriteString(publishers)
	return err
}

func (g *Generator) generatePublisher(publishers string, namespace *parser.Namespace) string {
	publishers += fmt.Sprintf("type %sPublisher struct {\n", namespace.Name)
	publishers += "\tClientProvider map[string]*frugal.Client\n"
	publishers += "\tSeqId          int32\n"
	publishers += "}\n\n"

	publishers += fmt.Sprintf("func New%sPublisher(t frugal.TransportFactory, "+
		"f thrift.TTransportFactory, p thrift.TProtocolFactory) *%sPublisher {\n", namespace.Name, namespace.Name)
	publishers += fmt.Sprintf("\treturn &%sPublisher{\n", namespace.Name)
	publishers += fmt.Sprintf("\t\tClientProvider: new%sClientProvider(t, f, p),\n", namespace.Name)
	publishers += fmt.Sprintf("\t\tSeqId:          0,\n")
	publishers += "\t}\n"
	publishers += "}\n\n"

	for _, op := range namespace.Operations {
		publishers += fmt.Sprintf("func (l *%sPublisher) %s(req *%s) error {\n", namespace.Name, op.Name, op.Param)
		publishers += fmt.Sprintf("\top := \"%s\"\n", op.Name)
		publishers += fmt.Sprintf("\ttopic := get%sPubSubTopic(op)\n", namespace.Name)
		publishers += "\tclient, ok := l.ClientProvider[topic]\n"
		publishers += "\tif !ok {\n"
		publishers += "\t\treturn thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, \"Unknown function \"+op)\n"
		publishers += "\t}\n"
		publishers += "\toprot := client.Protocol\n"
		publishers += "\tl.SeqId++\n"
		publishers += "\tif err := oprot.WriteMessageBegin(op, thrift.CALL, l.SeqId); err != nil {\n"
		publishers += "\t\treturn err\n"
		publishers += "\t}\n"
		publishers += "\tif err := req.Write(oprot); err != nil {\n"
		publishers += "\t\treturn err\n"
		publishers += "\t}\n"
		publishers += "\tif err := oprot.WriteMessageEnd(); err != nil {\n"
		publishers += "\t\treturn err\n"
		publishers += "\t}\n"
		publishers += "\treturn oprot.Flush()\n"
		publishers += "}\n\n"
	}

	publishers += fmt.Sprintf(
		"func new%sClientProvider(t frugal.TransportFactory, f thrift.TTransportFactory, p thrift.TProtocolFactory) "+
			"map[string]*frugal.Client {\n", namespace.Name)
	publishers += "\tprovider := make(map[string]*frugal.Client)\n\n"
	publishers += "\tvar (\n"
	publishers += "\t\ttopic     string\n"
	publishers += "\t\ttransport frugal.Transport\n"
	publishers += "\t)\n"
	for _, op := range namespace.Operations {
		publishers += fmt.Sprintf("\ttopic = get%sPubSubTopic(\"%s\")\n", namespace.Name, op.Name)
		publishers += "\ttransport = t.GetTransport(topic)\n"
		publishers += "\tif f != nil {\n"
		publishers += "\t\ttransport.ApplyProxy(f)\n"
		publishers += "\t}\n"
		publishers += "\tprovider[topic] = &frugal.Client{\n"
		publishers += "\t\tProtocol:  p.GetProtocol(transport.ThriftTransport()),\n"
		publishers += "\t\tTransport: transport,\n"
		publishers += "\t}\n\n"
	}
	publishers += "\treturn provider\n"
	publishers += "}\n\n"

	publishers += fmt.Sprintf("func get%sPubSubTopic(op string) string {\n", namespace.Name)
	publishers += "\treturn fmt.Sprintf(\"%s%s%s\", topicBase, delimiter, op)\n"
	publishers += "}"

	return publishers
}

func (g *Generator) GenerateSubscribers(file *os.File, namespaces []*parser.Namespace) error {
	subscribers := ""
	for _, namespace := range namespaces {
		subscribers = g.generateSubscriber(subscribers, namespace)
	}
	_, err := file.WriteString(subscribers)
	return err
}

func (g *Generator) generateSubscriber(subscribers string, namespace *parser.Namespace) string {
	subscribers += fmt.Sprintf("type %sSubscriber struct {\n", namespace.Name)
	subscribers += fmt.Sprintf("\tHandler        %sPubSub\n", namespace.Name)
	subscribers += fmt.Sprintf("\tClientProvider map[string]*frugal.Client\n")
	subscribers += "}\n\n"

	subscribers += fmt.Sprintf("func New%sSubscriber(handler %sPubSub, t frugal.TransportFactory, "+
		"f thrift.TTransportFactory, p thrift.TProtocolFactory) *%sSubscriber {\n", namespace.Name, namespace.Name, namespace.Name)
	subscribers += fmt.Sprintf("\treturn &%sSubscriber{\n", namespace.Name)
	subscribers += fmt.Sprintf("\t\tHandler:        handler,\n")
	subscribers += fmt.Sprintf("\t\tClientProvider: new%sClientProvider(t, f, p),\n", namespace.Name)
	subscribers += "\t}\n"
	subscribers += "}\n\n"

	prefix := ""
	for _, op := range namespace.Operations {
		subscribers += prefix
		prefix = "\n\n"
		subscribers += fmt.Sprintf("func (l *%sSubscriber) Subscribe%s() error {\n", namespace.Name, op.Name)
		subscribers += fmt.Sprintf("\top := \"%s\"\n", op.Name)
		subscribers += fmt.Sprintf("\ttopic := get%sPubSubTopic(op)\n", namespace.Name)
		subscribers += "\tclient, ok := l.ClientProvider[topic]\n"
		subscribers += "\tif !ok {\n"
		subscribers += "\t\treturn thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, \"Unknown function \"+op)\n"
		subscribers += "\t}\n\n"
		subscribers += "\tif err := client.Transport.Subscribe(); err != nil {\n"
		subscribers += "\t\treturn err\n"
		subscribers += "\t}\n\n"
		subscribers += "\tgo func() {\n"
		subscribers += "\t\tfor {\n"
		subscribers += fmt.Sprintf("\t\t\treceived, err := l.recv%s(op, client.Protocol)\n", op.Name)
		subscribers += "\t\t\tif err != nil {\n"
		subscribers += "\t\t\t\tif e, ok := err.(thrift.TTransportException); ok && e.TypeId() == thrift.END_OF_FILE {\n"
		subscribers += "\t\t\t\t\tbreak\n"
		subscribers += "\t\t\t\t}\n"
		subscribers += "\t\t\t\tlog.Println(\"frugal: error receiving:\", err)\n"
		subscribers += "\t\t\t}\n"
		subscribers += fmt.Sprintf("\t\t\tl.Handler.%s(received)\n", op.Name)
		subscribers += "\t\t}\n"
		subscribers += "\t}()\n\n"
		subscribers += "\treturn nil\n"
		subscribers += "}\n\n"

		subscribers += fmt.Sprintf("func (l *%sSubscriber) recv%s(op string, iprot thrift.TProtocol) (*%s, error) {\n",
			namespace.Name, op.Name, op.Param)
		subscribers += "\tname, _, _, err := iprot.ReadMessageBegin()\n"
		subscribers += "\tif err != nil {\n"
		subscribers += "\t\treturn nil, err\n"
		subscribers += "\t}\n"
		subscribers += "\tif name != op {\n"
		subscribers += "\t\tiprot.Skip(thrift.STRUCT)\n"
		subscribers += "\t\tiprot.ReadMessageEnd()\n"
		subscribers += "\t\tx9 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, \"Unknown function \"+name)\n"
		subscribers += "\t\treturn nil, x9\n"
		subscribers += "\t}\n"
		subscribers += fmt.Sprintf("\treq := &%s{}\n", op.Param)
		subscribers += "\tif err := req.Read(iprot); err != nil {\n"
		subscribers += "\t\treturn nil, err\n"
		subscribers += "\t}\n\n"
		subscribers += "\tiprot.ReadMessageEnd()\n"
		subscribers += "\treturn req, nil\n"
		subscribers += "}\n\n"

		subscribers += fmt.Sprintf("func (l *%sSubscriber) Unsubscribe%s() error {\n", namespace.Name, op.Name)
		subscribers += fmt.Sprintf("\top := \"%s\"\n", op.Name)
		subscribers += fmt.Sprintf("\ttopic := get%sPubSubTopic(op)\n", namespace.Name)
		subscribers += "\tclient, ok := l.ClientProvider[topic]\n"
		subscribers += "\tif !ok {\n"
		subscribers += "\t\treturn thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, \"Unknown function \"+op)\n"
		subscribers += "\t}\n\n"
		subscribers += "\treturn client.Transport.Unsubscribe()\n"
		subscribers += "}"
	}
	subscribers += "\n"

	return subscribers
}
