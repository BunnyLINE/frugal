package java

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/globals"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	lang                     = "java"
	defaultOutputDir         = "gen-java"
	tab                      = "\t"
	tabtab                   = tab + tab
	tabtabtab                = tab + tab + tab
	tabtabtabtab             = tab + tab + tab + tab
	tabtabtabtabtab          = tab + tab + tab + tab + tab
	tabtabtabtabtabtab       = tab + tab + tab + tab + tab + tab
	tabtabtabtabtabtabtab    = tab + tab + tab + tab + tab + tab + tab
	tabtabtabtabtabtabtabtab = tab + tab + tab + tab + tab + tab + tab + tab
)

type Generator struct {
	*generator.BaseGenerator
	time time.Time
}

func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{
		&generator.BaseGenerator{Options: options},
		globals.Now,
	}
}

func (g *Generator) GenerateThrift() bool {
	return false
}

func (g *Generator) GetOutputDir(dir string, f *parser.Frugal) string {
	if pkg, ok := f.Thrift.Namespace(lang); ok {
		path := generator.GetPackageComponents(pkg)
		dir = filepath.Join(append([]string{dir}, path...)...)
	}
	return dir
}

func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

func (g *Generator) GenerateDependencies(f *parser.Frugal, dir string) error {
	return nil
}

func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.PublishFile:
		return g.CreateFile(strings.Title(name)+"Publisher", outputDir, lang, false)
	case generator.SubscribeFile:
		return g.CreateFile(strings.Title(name)+"Subscriber", outputDir, lang, false)
	case generator.CombinedAsyncFile:
		return g.CreateFile(strings.Title(name)+"Async", outputDir, lang, false)
	default:
		return nil, fmt.Errorf("frugal: Bad file type for Java generator: %s", fileType)
	}
}

func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		"/**\n"+
			" * Autogenerated by Frugal Compiler (%s)\n"+
			" * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n"+
			" *  @generated\n"+
			" */",
		globals.Version)

	_, err := file.WriteString(comment)
	return err
}

func (g *Generator) GenerateServicePackage(file *os.File, f *parser.Frugal, s *parser.Service) error {
	return g.generatePackage(file, f)
}

func (g *Generator) GenerateScopePackage(file *os.File, f *parser.Frugal, s *parser.Scope) error {
	return g.generatePackage(file, f)
}

func (g *Generator) GenerateAsyncPackage(file *os.File, f *parser.Frugal, a *parser.Async) error {
	return g.generatePackage(file, f)
}

func (g *Generator) generatePackage(file *os.File, f *parser.Frugal) error {
	pkg, ok := f.Thrift.Namespace(lang)
	if !ok {
		return nil
	}
	_, err := file.WriteString(fmt.Sprintf("package %s;", pkg))
	return err
}

func (g *Generator) GenerateServiceImports(file *os.File, s *parser.Service) error {
	// TODO
	return nil
}

func (g *Generator) GenerateScopeImports(file *os.File, f *parser.Frugal, s *parser.Scope) error {
	imports := "import com.workiva.frugal.Provider;\n"
	imports += "import com.workiva.frugal.Transport;\n"
	imports += "import com.workiva.frugal.TransportFactory;\n"
	imports += "import com.workiva.frugal.Subscription;\n"
	imports += "import org.apache.thrift.TException;\n"
	imports += "import org.apache.thrift.protocol.*;\n"
	imports += "import org.apache.thrift.TApplicationException;\n\n"
	imports += "import org.apache.thrift.transport.TTransportException;\n\n"
	imports += "import org.apache.thrift.transport.TTransportFactory;\n\n"
	imports += "import javax.annotation.Generated;"
	_, err := file.WriteString(imports)
	return err
}

func (g *Generator) GenerateAsyncImports(file *os.File, f *parser.Frugal, a *parser.Async) error {
	imports := "import com.workiva.frugal.Context;\n"
	_, err := file.WriteString(imports)
	return err
}

func (g *Generator) GenerateConstants(file *os.File, name string) error {
	return nil
}

func (g *Generator) GeneratePublisher(file *os.File, scope *parser.Scope) error {
	publisher := ""
	if scope.Comment != nil {
		publisher += g.GenerateBlockComment(scope.Comment, "")
	}
	publisher += fmt.Sprintf("@Generated(value = \"Autogenerated by Frugal Compiler (%s)\", "+
		"date = \"%s\")\n", globals.Version, g.time.Format("2006-1-2"))
	publisher += fmt.Sprintf("public class %sPublisher {\n\n", strings.Title(scope.Name))

	publisher += fmt.Sprintf(tab+"private static final String delimiter = \"%s\";\n\n", globals.TopicDelimiter)

	publisher += tab + "private Transport transport;\n"
	publisher += tab + "private TProtocol protocol;\n"
	publisher += tab + "private int seqId;\n\n"

	publisher += fmt.Sprintf(tab+"public %sPublisher(Provider provider) {\n", strings.Title(scope.Name))
	publisher += tabtab + "Provider.Client client = provider.build();\n"
	publisher += tabtab + "transport = client.getTransport();\n"
	publisher += tabtab + "protocol = client.getProtocol();\n"
	publisher += tab + "}\n\n"

	args := ""
	if len(scope.Prefix.Variables) > 0 {
		for _, variable := range scope.Prefix.Variables {
			args = fmt.Sprintf("%sString %s, ", args, variable)
		}
	}
	prefix := ""
	for _, op := range scope.Operations {
		publisher += prefix
		prefix = "\n\n"
		if op.Comment != nil {
			publisher += g.GenerateBlockComment(op.Comment, tab)
		}
		publisher += fmt.Sprintf(tab+"public void publish%s(%s%s req) throws TException {\n", op.Name, args, g.qualifiedParamName(op))
		publisher += fmt.Sprintf(tabtab+"String op = \"%s\";\n", op.Name)
		publisher += fmt.Sprintf(tabtab+"String prefix = %s;\n", generatePrefixStringTemplate(scope))
		publisher += tabtab + "String topic = String.format(\"%s" + strings.Title(scope.Name) + "%s%s\", prefix, delimiter, op);\n"
		publisher += tabtab + "transport.preparePublish(topic);\n"
		publisher += tabtab + "seqId++;\n"
		publisher += tabtab + "protocol.writeMessageBegin(new TMessage(op, TMessageType.CALL, seqId));\n"
		publisher += tabtab + "req.write(protocol);\n"
		publisher += tabtab + "protocol.writeMessageEnd();\n"
		publisher += tabtab + "transport.flush();\n"
		publisher += tab + "}\n"
	}

	publisher += "}"

	_, err := file.WriteString(publisher)
	return err
}

func generatePrefixStringTemplate(scope *parser.Scope) string {
	if len(scope.Prefix.Variables) == 0 {
		if scope.Prefix.String == "" {
			return `""`
		}
		return fmt.Sprintf(`"%s%s"`, scope.Prefix.String, globals.TopicDelimiter)
	}
	template := "String.format(\""
	template += scope.Prefix.Template()
	template += globals.TopicDelimiter + "\", "
	prefix := ""
	for _, variable := range scope.Prefix.Variables {
		template += prefix + variable
		prefix = ", "
	}
	template += ")"
	return template
}

func (g *Generator) GenerateSubscriber(file *os.File, scope *parser.Scope) error {
	subscriber := ""
	if scope.Comment != nil {
		subscriber += g.GenerateBlockComment(scope.Comment, "")
	}
	subscriber += fmt.Sprintf("@Generated(value = \"Autogenerated by Frugal Compiler (%s)\", "+
		"date = \"%s\")\n", globals.Version, g.time.Format("2006-1-2"))
	subscriber += fmt.Sprintf("public class %sSubscriber {\n\n", strings.Title(scope.Name))

	subscriber += fmt.Sprintf(tab+"private static final String delimiter = \"%s\";\n\n", globals.TopicDelimiter)

	subscriber += tab + "private final Provider provider;\n\n"

	subscriber += fmt.Sprintf(tab+"public %sSubscriber(Provider provider) {\n",
		strings.Title(scope.Name))
	subscriber += tabtab + "this.provider = provider;\n"
	subscriber += tab + "}\n\n"

	args := ""
	if len(scope.Prefix.Variables) > 0 {
		for _, variable := range scope.Prefix.Variables {
			args = fmt.Sprintf("%sString %s, ", args, variable)
		}
	}
	prefix := ""
	for _, op := range scope.Operations {
		subscriber += fmt.Sprintf(tab+"public interface %sHandler {\n", op.Name)
		subscriber += fmt.Sprintf(tabtab+"void on%s(%s req);\n", op.Name, g.qualifiedParamName(op))
		subscriber += tab + "}\n\n"

		subscriber += prefix
		prefix = "\n\n"
		if op.Comment != nil {
			subscriber += g.GenerateBlockComment(op.Comment, tab)
		}
		subscriber += fmt.Sprintf(tab+"public Subscription subscribe%s(%sfinal %sHandler handler) throws TException {\n",
			op.Name, args, op.Name)
		subscriber += fmt.Sprintf(tabtab+"final String op = \"%s\";\n", op.Name)
		subscriber += fmt.Sprintf(tabtab+"String prefix = %s;\n", generatePrefixStringTemplate(scope))
		subscriber += tabtab + "String topic = String.format(\"%s" + strings.Title(scope.Name) + "%s%s\", prefix, delimiter, op);\n"
		subscriber += tabtab + "final Provider.Client client = provider.build();\n"
		subscriber += tabtab + "Transport transport = client.getTransport();\n"
		subscriber += tabtab + "transport.subscribe(topic);\n\n"

		subscriber += tabtab + "final Subscription sub = new Subscription(topic, transport);\n"
		subscriber += tabtab + "new Thread(new Runnable() {\n"
		subscriber += tabtabtab + "public void run() {\n"
		subscriber += tabtabtabtab + "while (true) {\n"
		subscriber += tabtabtabtabtab + "try {\n"
		subscriber += tabtabtabtabtabtab + fmt.Sprintf("%s received = recv%s(op, client.getProtocol());\n",
			g.qualifiedParamName(op), op.Name)
		subscriber += tabtabtabtabtabtab + fmt.Sprintf("handler.on%s(received);\n", op.Name)
		subscriber += tabtabtabtabtab + "} catch (TException e) {\n"
		subscriber += tabtabtabtabtabtab + "if (e instanceof TTransportException) {\n"
		subscriber += tabtabtabtabtabtabtab + "TTransportException transportException = (TTransportException) e;\n"
		subscriber += tabtabtabtabtabtabtab + "if (transportException.getType() == TTransportException.END_OF_FILE) {\n"
		subscriber += tabtabtabtabtabtabtabtab + "return;\n"
		subscriber += tabtabtabtabtabtabtab + "}\n"
		subscriber += tabtabtabtabtabtab + "}\n"
		subscriber += tabtabtabtabtabtab + "e.printStackTrace();\n"
		subscriber += tabtabtabtabtabtab + "sub.signal(e);\n"
		subscriber += tabtabtabtabtabtab + "sub.unsubscribe();\n"
		subscriber += tabtabtabtabtab + "}\n"
		subscriber += tabtabtabtab + "}\n"
		subscriber += tabtabtab + "}\n"
		subscriber += tabtab + "}).start();\n\n"

		subscriber += tabtab + "return sub;\n"
		subscriber += tab + "}\n\n"

		subscriber += tab + fmt.Sprintf("private %s recv%s(String op, TProtocol iprot) throws TException {\n", g.qualifiedParamName(op), op.Name)
		subscriber += tabtab + "TMessage msg = iprot.readMessageBegin();\n"
		subscriber += tabtab + "if (!msg.name.equals(op)) {\n"
		subscriber += tabtabtab + "TProtocolUtil.skip(iprot, TType.STRUCT);\n"
		subscriber += tabtabtab + "iprot.readMessageEnd();\n"
		subscriber += tabtabtab + "throw new TApplicationException(TApplicationException.UNKNOWN_METHOD);\n"
		subscriber += tabtab + "}\n"
		subscriber += tabtab + fmt.Sprintf("%s req = new %s();\n", g.qualifiedParamName(op), g.qualifiedParamName(op))
		subscriber += tabtab + "req.read(iprot);\n"
		subscriber += tabtab + "iprot.readMessageEnd();\n"
		subscriber += tabtab + "return req;\n"
		subscriber += tab + "}\n\n"
	}
	subscriber += "\n}"

	_, err := file.WriteString(subscriber)
	return err
}

func (g *Generator) GenerateService(file *os.File, p *parser.Frugal, s *parser.Service) error {
	// TODO
	return nil
}

func (g *Generator) GenerateAsync(file *os.File, f *parser.Frugal, async *parser.Async) error {
	// TODO: Implement async client/processor. For now, generating an interface
	// which can be used for stubbing.
	contents := g.generateAsyncInterface(async)

	_, err := file.WriteString(contents)
	return err
}

func (g *Generator) generateAsyncInterface(async *parser.Async) string {
	contents := ""
	if async.Comment != nil {
		contents += g.GenerateBlockComment(async.Comment, "")
	}
	contents += fmt.Sprintf("public interface %sAsync {\n", strings.Title(async.Name))
	for _, method := range async.Methods {
		if method.Comment != nil {
			contents += g.GenerateBlockComment(method.Comment, "\t")
		}
		contents += fmt.Sprintf("\t%s %s(Context ctx%s);\n", g.getJavaTypeFromThriftType(method.ReturnType),
			method.Name, g.generateInterfaceArgs(method.Arguments))
	}
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateInterfaceArgs(args []*parser.Field) string {
	argStr := ""
	prefix := ", "
	for _, arg := range args {
		argStr += prefix + g.getJavaTypeFromThriftType(arg.Type) + " " + arg.Name
	}
	return argStr
}

func (g *Generator) getJavaTypeFromThriftType(t *parser.Type) string {
	if t == nil {
		return "void"
	}
	typeName := g.Frugal.Thrift.UnderlyingType(t.Name)
	switch typeName {
	case "bool":
		return "boolean"
	case "byte":
		return "byte"
	case "i16":
		return "short"
	case "i32":
		return "int"
	case "i64":
		return "long"
	case "double":
		return "double"
	case "string":
		return "String"
	case "binary":
		return "java.nio.ByteBuffer"
	case "list":
		return fmt.Sprintf("List<%s>", g.getJavaTypeFromThriftType(t.ValueType))
	case "set":
		return fmt.Sprintf("Set<%s>", g.getJavaTypeFromThriftType(t.ValueType))
	case "map":
		return fmt.Sprintf("Map<%s, %s>", g.getJavaTypeFromThriftType(t.KeyType),
			g.getJavaTypeFromThriftType(t.ValueType))
	default:
		// This is a custom type, return a pointer to it
		return g.qualifiedTypeName(t)
	}
}

func (g *Generator) qualifiedTypeName(t *parser.Type) string {
	param := t.ParamName()
	include := t.IncludeName()
	if include != "" {
		namespace, ok := g.Frugal.NamespaceForInclude(include, lang)
		if !ok {
			namespace = include
		}
		param = fmt.Sprintf("%s.%s", namespace, param)
	}
	return param
}

func (g *Generator) qualifiedParamName(op *parser.Operation) string {
	param := op.ParamName()
	include := op.IncludeName()
	if include != "" {
		namespace, ok := g.Frugal.NamespaceForInclude(include, lang)
		if ok {
			param = fmt.Sprintf("%s.%s", namespace, param)
		}
	}
	return param
}
