/**
 * Autogenerated by Frugal Compiler (3.14.1)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *
 * @generated
 */

package frugal.test;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Objects;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.workiva.frugal.FContext;
import com.workiva.frugal.exception.TApplicationExceptionType;
import com.workiva.frugal.exception.TTransportExceptionType;
import com.workiva.frugal.middleware.InvocationHandler;
import com.workiva.frugal.middleware.ServiceMiddleware;
import com.workiva.frugal.processor.FBaseProcessor;
import com.workiva.frugal.processor.FProcessor;
import com.workiva.frugal.processor.FProcessorFunction;
import com.workiva.frugal.protocol.*;
import com.workiva.frugal.provider.FServiceClient;
import com.workiva.frugal.provider.FServiceProvider;
import com.workiva.frugal.transport.FTransport;
import com.workiva.frugal.transport.TMemoryOutputBuffer;
import org.apache.thrift.TApplicationException;
import org.apache.thrift.TException;
import org.apache.thrift.protocol.TMessage;
import org.apache.thrift.protocol.TMessageType;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.transport.TTransportException;
import java.util.Arrays;
import java.util.concurrent.*;


public class FFrugalTest {

	private static final Logger logger = LoggerFactory.getLogger(FFrugalTest.class);

	public interface Iface extends FSuperService.Iface, InternalIface {}

	/** For internal use only. Contains only the methods defined directly by the service. */
	public interface InternalIface {

		public void testVoid(FContext ctx) throws TException;

		public String testString(FContext ctx, String thing) throws TException;

		/**
		 * @deprecated use something else
		 */
		@Deprecated
		public boolean testBool(FContext ctx, boolean thing) throws TException;

		public byte testByte(FContext ctx, byte thing) throws TException;

		public int testI32(FContext ctx, int thing) throws TException;

		public long testI64(FContext ctx, long thing) throws TException;

		public double testDouble(FContext ctx, double thing) throws TException;

		public java.nio.ByteBuffer testBinary(FContext ctx, java.nio.ByteBuffer thing) throws TException;

		public Xtruct testStruct(FContext ctx, Xtruct thing) throws TException;

		public Xtruct2 testNest(FContext ctx, Xtruct2 thing) throws TException;

		public java.util.Map<Integer, Integer> testMap(FContext ctx, java.util.Map<Integer, Integer> thing) throws TException;

		public java.util.Map<String, String> testStringMap(FContext ctx, java.util.Map<String, String> thing) throws TException;

		public java.util.Set<Integer> testSet(FContext ctx, java.util.Set<Integer> thing) throws TException;

		public java.util.List<Integer> testList(FContext ctx, java.util.List<Integer> thing) throws TException;

		public Numberz testEnum(FContext ctx, Numberz thing) throws TException;

		public long testTypedef(FContext ctx, long thing) throws TException;

		public java.util.Map<Integer, java.util.Map<Integer, Integer>> testMapMap(FContext ctx, int hello) throws TException;

		public boolean TestUppercaseMethod(FContext ctx, boolean thing) throws TException;

		public java.util.Map<Long, java.util.Map<Numberz, Insanity>> testInsanity(FContext ctx, Insanity argument) throws TException;

		public Xtruct testMulti(FContext ctx, byte arg0, int arg1, long arg2, java.util.Map<Short, String> arg3, Numberz arg4, long arg5) throws TException;

		public void testException(FContext ctx, String arg) throws TException, Xception;

		public Xtruct testMultiException(FContext ctx, String arg0, String arg1) throws TException, Xception, Xception2;

		public void testUncaughtException(FContext ctx) throws TException;

		public void testUncheckedTApplicationException(FContext ctx) throws TException;

		public void testRequestTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException;

		public java.nio.ByteBuffer testResponseTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException;

		public void testOneway(FContext ctx, int millisecondsToSleep) throws TException;

	}

	public static class Client extends FSuperService.Client implements Iface {

		private InternalIface proxy;

		public Client(FServiceProvider provider, ServiceMiddleware... middleware) {
			super(provider, middleware);
			InternalIface client = new InternalClient(provider);
			List<ServiceMiddleware> combined = new ArrayList<ServiceMiddleware>(Arrays.asList(middleware));
			combined.addAll(provider.getMiddleware());
			middleware = combined.toArray(new ServiceMiddleware[0]);
			proxy = InvocationHandler.composeMiddleware(client, InternalIface.class, middleware);
		}

		public void testVoid(FContext ctx) throws TException {
			proxy.testVoid(ctx);
		}

		public String testString(FContext ctx, String thing) throws TException {
			return proxy.testString(ctx, thing);
		}

		@Deprecated
		public boolean testBool(FContext ctx, boolean thing) throws TException {
			logger.warn("Call to deprecated function 'FrugalTest.testBool'");
			return proxy.testBool(ctx, thing);
		}

		public byte testByte(FContext ctx, byte thing) throws TException {
			return proxy.testByte(ctx, thing);
		}

		public int testI32(FContext ctx, int thing) throws TException {
			return proxy.testI32(ctx, thing);
		}

		public long testI64(FContext ctx, long thing) throws TException {
			return proxy.testI64(ctx, thing);
		}

		public double testDouble(FContext ctx, double thing) throws TException {
			return proxy.testDouble(ctx, thing);
		}

		public java.nio.ByteBuffer testBinary(FContext ctx, java.nio.ByteBuffer thing) throws TException {
			return proxy.testBinary(ctx, thing);
		}

		public Xtruct testStruct(FContext ctx, Xtruct thing) throws TException {
			return proxy.testStruct(ctx, thing);
		}

		public Xtruct2 testNest(FContext ctx, Xtruct2 thing) throws TException {
			return proxy.testNest(ctx, thing);
		}

		public java.util.Map<Integer, Integer> testMap(FContext ctx, java.util.Map<Integer, Integer> thing) throws TException {
			return proxy.testMap(ctx, thing);
		}

		public java.util.Map<String, String> testStringMap(FContext ctx, java.util.Map<String, String> thing) throws TException {
			return proxy.testStringMap(ctx, thing);
		}

		public java.util.Set<Integer> testSet(FContext ctx, java.util.Set<Integer> thing) throws TException {
			return proxy.testSet(ctx, thing);
		}

		public java.util.List<Integer> testList(FContext ctx, java.util.List<Integer> thing) throws TException {
			return proxy.testList(ctx, thing);
		}

		public Numberz testEnum(FContext ctx, Numberz thing) throws TException {
			return proxy.testEnum(ctx, thing);
		}

		public long testTypedef(FContext ctx, long thing) throws TException {
			return proxy.testTypedef(ctx, thing);
		}

		public java.util.Map<Integer, java.util.Map<Integer, Integer>> testMapMap(FContext ctx, int hello) throws TException {
			return proxy.testMapMap(ctx, hello);
		}

		public boolean TestUppercaseMethod(FContext ctx, boolean thing) throws TException {
			return proxy.TestUppercaseMethod(ctx, thing);
		}

		public java.util.Map<Long, java.util.Map<Numberz, Insanity>> testInsanity(FContext ctx, Insanity argument) throws TException {
			return proxy.testInsanity(ctx, argument);
		}

		public Xtruct testMulti(FContext ctx, byte arg0, int arg1, long arg2, java.util.Map<Short, String> arg3, Numberz arg4, long arg5) throws TException {
			return proxy.testMulti(ctx, arg0, arg1, arg2, arg3, arg4, arg5);
		}

		public void testException(FContext ctx, String arg) throws TException, Xception {
			proxy.testException(ctx, arg);
		}

		public Xtruct testMultiException(FContext ctx, String arg0, String arg1) throws TException, Xception, Xception2 {
			return proxy.testMultiException(ctx, arg0, arg1);
		}

		public void testUncaughtException(FContext ctx) throws TException {
			proxy.testUncaughtException(ctx);
		}

		public void testUncheckedTApplicationException(FContext ctx) throws TException {
			proxy.testUncheckedTApplicationException(ctx);
		}

		public void testRequestTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException {
			proxy.testRequestTooLarge(ctx, request);
		}

		public java.nio.ByteBuffer testResponseTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException {
			return proxy.testResponseTooLarge(ctx, request);
		}

		public void testOneway(FContext ctx, int millisecondsToSleep) throws TException {
			proxy.testOneway(ctx, millisecondsToSleep);
		}

	}

	private static class InternalClient extends FServiceClient implements InternalIface {
		public InternalClient(FServiceProvider provider) {
			super(provider);
		}
		public void testVoid(FContext ctx) throws TException {
			testVoid_args args = new testVoid_args();
			testVoid_result res = new testVoid_result();
			requestBase(ctx, "testVoid", args, res);
		}
		public String testString(FContext ctx, String thing) throws TException {
			testString_args args = new testString_args();
			args.setThing(thing);
			testString_result res = new testString_result();
			requestBase(ctx, "testString", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testString failed: unknown result");
		}
		public boolean testBool(FContext ctx, boolean thing) throws TException {
			testBool_args args = new testBool_args();
			args.setThing(thing);
			testBool_result res = new testBool_result();
			requestBase(ctx, "testBool", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testBool failed: unknown result");
		}
		public byte testByte(FContext ctx, byte thing) throws TException {
			testByte_args args = new testByte_args();
			args.setThing(thing);
			testByte_result res = new testByte_result();
			requestBase(ctx, "testByte", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testByte failed: unknown result");
		}
		public int testI32(FContext ctx, int thing) throws TException {
			testI32_args args = new testI32_args();
			args.setThing(thing);
			testI32_result res = new testI32_result();
			requestBase(ctx, "testI32", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testI32 failed: unknown result");
		}
		public long testI64(FContext ctx, long thing) throws TException {
			testI64_args args = new testI64_args();
			args.setThing(thing);
			testI64_result res = new testI64_result();
			requestBase(ctx, "testI64", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testI64 failed: unknown result");
		}
		public double testDouble(FContext ctx, double thing) throws TException {
			testDouble_args args = new testDouble_args();
			args.setThing(thing);
			testDouble_result res = new testDouble_result();
			requestBase(ctx, "testDouble", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testDouble failed: unknown result");
		}
		public java.nio.ByteBuffer testBinary(FContext ctx, java.nio.ByteBuffer thing) throws TException {
			testBinary_args args = new testBinary_args();
			args.setThing(thing);
			testBinary_result res = new testBinary_result();
			requestBase(ctx, "testBinary", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testBinary failed: unknown result");
		}
		public Xtruct testStruct(FContext ctx, Xtruct thing) throws TException {
			testStruct_args args = new testStruct_args();
			args.setThing(thing);
			testStruct_result res = new testStruct_result();
			requestBase(ctx, "testStruct", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testStruct failed: unknown result");
		}
		public Xtruct2 testNest(FContext ctx, Xtruct2 thing) throws TException {
			testNest_args args = new testNest_args();
			args.setThing(thing);
			testNest_result res = new testNest_result();
			requestBase(ctx, "testNest", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testNest failed: unknown result");
		}
		public java.util.Map<Integer, Integer> testMap(FContext ctx, java.util.Map<Integer, Integer> thing) throws TException {
			testMap_args args = new testMap_args();
			args.setThing(thing);
			testMap_result res = new testMap_result();
			requestBase(ctx, "testMap", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testMap failed: unknown result");
		}
		public java.util.Map<String, String> testStringMap(FContext ctx, java.util.Map<String, String> thing) throws TException {
			testStringMap_args args = new testStringMap_args();
			args.setThing(thing);
			testStringMap_result res = new testStringMap_result();
			requestBase(ctx, "testStringMap", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testStringMap failed: unknown result");
		}
		public java.util.Set<Integer> testSet(FContext ctx, java.util.Set<Integer> thing) throws TException {
			testSet_args args = new testSet_args();
			args.setThing(thing);
			testSet_result res = new testSet_result();
			requestBase(ctx, "testSet", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testSet failed: unknown result");
		}
		public java.util.List<Integer> testList(FContext ctx, java.util.List<Integer> thing) throws TException {
			testList_args args = new testList_args();
			args.setThing(thing);
			testList_result res = new testList_result();
			requestBase(ctx, "testList", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testList failed: unknown result");
		}
		public Numberz testEnum(FContext ctx, Numberz thing) throws TException {
			testEnum_args args = new testEnum_args();
			args.setThing(thing);
			testEnum_result res = new testEnum_result();
			requestBase(ctx, "testEnum", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testEnum failed: unknown result");
		}
		public long testTypedef(FContext ctx, long thing) throws TException {
			testTypedef_args args = new testTypedef_args();
			args.setThing(thing);
			testTypedef_result res = new testTypedef_result();
			requestBase(ctx, "testTypedef", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testTypedef failed: unknown result");
		}
		public java.util.Map<Integer, java.util.Map<Integer, Integer>> testMapMap(FContext ctx, int hello) throws TException {
			testMapMap_args args = new testMapMap_args();
			args.setHello(hello);
			testMapMap_result res = new testMapMap_result();
			requestBase(ctx, "testMapMap", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testMapMap failed: unknown result");
		}
		public boolean TestUppercaseMethod(FContext ctx, boolean thing) throws TException {
			TestUppercaseMethod_args args = new TestUppercaseMethod_args();
			args.setThing(thing);
			TestUppercaseMethod_result res = new TestUppercaseMethod_result();
			requestBase(ctx, "testUppercaseMethod", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "TestUppercaseMethod failed: unknown result");
		}
		public java.util.Map<Long, java.util.Map<Numberz, Insanity>> testInsanity(FContext ctx, Insanity argument) throws TException {
			testInsanity_args args = new testInsanity_args();
			args.setArgument(argument);
			testInsanity_result res = new testInsanity_result();
			requestBase(ctx, "testInsanity", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testInsanity failed: unknown result");
		}
		public Xtruct testMulti(FContext ctx, byte arg0, int arg1, long arg2, java.util.Map<Short, String> arg3, Numberz arg4, long arg5) throws TException {
			testMulti_args args = new testMulti_args();
			args.setArg0(arg0);
			args.setArg1(arg1);
			args.setArg2(arg2);
			args.setArg3(arg3);
			args.setArg4(arg4);
			args.setArg5(arg5);
			testMulti_result res = new testMulti_result();
			requestBase(ctx, "testMulti", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testMulti failed: unknown result");
		}
		public void testException(FContext ctx, String arg) throws TException, Xception {
			testException_args args = new testException_args();
			args.setArg(arg);
			testException_result res = new testException_result();
			requestBase(ctx, "testException", args, res);
			if (res.err1 != null) {
				throw res.err1;
			}
		}
		public Xtruct testMultiException(FContext ctx, String arg0, String arg1) throws TException, Xception, Xception2 {
			testMultiException_args args = new testMultiException_args();
			args.setArg0(arg0);
			args.setArg1(arg1);
			testMultiException_result res = new testMultiException_result();
			requestBase(ctx, "testMultiException", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			if (res.err1 != null) {
				throw res.err1;
			}
			if (res.err2 != null) {
				throw res.err2;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testMultiException failed: unknown result");
		}
		public void testUncaughtException(FContext ctx) throws TException {
			testUncaughtException_args args = new testUncaughtException_args();
			testUncaughtException_result res = new testUncaughtException_result();
			requestBase(ctx, "testUncaughtException", args, res);
		}
		public void testUncheckedTApplicationException(FContext ctx) throws TException {
			testUncheckedTApplicationException_args args = new testUncheckedTApplicationException_args();
			testUncheckedTApplicationException_result res = new testUncheckedTApplicationException_result();
			requestBase(ctx, "testUncheckedTApplicationException", args, res);
		}
		public void testRequestTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException {
			testRequestTooLarge_args args = new testRequestTooLarge_args();
			args.setRequest(request);
			testRequestTooLarge_result res = new testRequestTooLarge_result();
			requestBase(ctx, "testRequestTooLarge", args, res);
		}
		public java.nio.ByteBuffer testResponseTooLarge(FContext ctx, java.nio.ByteBuffer request) throws TException {
			testResponseTooLarge_args args = new testResponseTooLarge_args();
			args.setRequest(request);
			testResponseTooLarge_result res = new testResponseTooLarge_result();
			requestBase(ctx, "testResponseTooLarge", args, res);
			if (res.isSetSuccess()) {
				return res.success;
			}
			throw new TApplicationException(TApplicationExceptionType.MISSING_RESULT, "testResponseTooLarge failed: unknown result");
		}
		public void testOneway(FContext ctx, int millisecondsToSleep) throws TException {
			testOneway_args args = new testOneway_args();
			args.setMillisecondsToSleep(millisecondsToSleep);
			onewayBase(ctx, "testOneway", args);
		}
	}

	public static class Processor extends FSuperService.Processor implements FProcessor {

		private Iface handler;

		public Processor(Iface iface, ServiceMiddleware... middleware) {
			super(iface, middleware);
			handler = InvocationHandler.composeMiddleware(iface, Iface.class, middleware);
		}

		protected java.util.Map<String, FProcessorFunction> getProcessMap() {
			java.util.Map<String, FProcessorFunction> processMap = super.getProcessMap();
			processMap.put("testVoid", new TestVoid());
			processMap.put("testString", new TestString());
			processMap.put("testBool", new TestBool());
			processMap.put("testByte", new TestByte());
			processMap.put("testI32", new TestI32());
			processMap.put("testI64", new TestI64());
			processMap.put("testDouble", new TestDouble());
			processMap.put("testBinary", new TestBinary());
			processMap.put("testStruct", new TestStruct());
			processMap.put("testNest", new TestNest());
			processMap.put("testMap", new TestMap());
			processMap.put("testStringMap", new TestStringMap());
			processMap.put("testSet", new TestSet());
			processMap.put("testList", new TestList());
			processMap.put("testEnum", new TestEnum());
			processMap.put("testTypedef", new TestTypedef());
			processMap.put("testMapMap", new TestMapMap());
			processMap.put("testUppercaseMethod", new TestUppercaseMethod());
			processMap.put("testInsanity", new TestInsanity());
			processMap.put("testMulti", new TestMulti());
			processMap.put("testException", new TestException());
			processMap.put("testMultiException", new TestMultiException());
			processMap.put("testUncaughtException", new TestUncaughtException());
			processMap.put("testUncheckedTApplicationException", new TestUncheckedTApplicationException());
			processMap.put("testRequestTooLarge", new TestRequestTooLarge());
			processMap.put("testResponseTooLarge", new TestResponseTooLarge());
			processMap.put("testOneway", new TestOneway());
			return processMap;
		}

		protected java.util.Map<String, java.util.Map<String, String>> getAnnotationsMap() {
			java.util.Map<String, java.util.Map<String, String>> annotationsMap = super.getAnnotationsMap();
			java.util.Map<String, String> testBoolMap = new java.util.HashMap<>();
			testBoolMap.put("deprecated", "use something else");
			annotationsMap.put("testBool", testBoolMap);
			return annotationsMap;
		}

		@Override
		public void addMiddleware(ServiceMiddleware middleware) {
			super.addMiddleware(middleware);
			handler = InvocationHandler.composeMiddleware(handler, Iface.class, new ServiceMiddleware[]{middleware});
		}

		private class TestVoid implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testVoid_args args = new testVoid_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testVoid", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testVoid_result result = new testVoid_result();
				try {
					handler.testVoid(ctx);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testVoid", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testVoid", "Internal error processing testVoid: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testVoid", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testVoid", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestString implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testString_args args = new testString_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testString", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testString_result result = new testString_result();
				try {
					result.success = handler.testString(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testString", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testString", "Internal error processing testString: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testString", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testString", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestBool implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				logger.warn("Deprecated function 'FrugalTest.testBool' was called by a client");
				testBool_args args = new testBool_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testBool", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testBool_result result = new testBool_result();
				try {
					result.success = handler.testBool(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testBool", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testBool", "Internal error processing testBool: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testBool", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testBool", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestByte implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testByte_args args = new testByte_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testByte", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testByte_result result = new testByte_result();
				try {
					result.success = handler.testByte(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testByte", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testByte", "Internal error processing testByte: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testByte", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testByte", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestI32 implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testI32_args args = new testI32_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testI32", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testI32_result result = new testI32_result();
				try {
					result.success = handler.testI32(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testI32", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testI32", "Internal error processing testI32: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testI32", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testI32", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestI64 implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testI64_args args = new testI64_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testI64", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testI64_result result = new testI64_result();
				try {
					result.success = handler.testI64(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testI64", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testI64", "Internal error processing testI64: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testI64", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testI64", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestDouble implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testDouble_args args = new testDouble_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testDouble", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testDouble_result result = new testDouble_result();
				try {
					result.success = handler.testDouble(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testDouble", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testDouble", "Internal error processing testDouble: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testDouble", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testDouble", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestBinary implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testBinary_args args = new testBinary_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testBinary", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testBinary_result result = new testBinary_result();
				try {
					result.success = handler.testBinary(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testBinary", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testBinary", "Internal error processing testBinary: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testBinary", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testBinary", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestStruct implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testStruct_args args = new testStruct_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testStruct", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testStruct_result result = new testStruct_result();
				try {
					result.success = handler.testStruct(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testStruct", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testStruct", "Internal error processing testStruct: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testStruct", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testStruct", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestNest implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testNest_args args = new testNest_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testNest", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testNest_result result = new testNest_result();
				try {
					result.success = handler.testNest(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testNest", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testNest", "Internal error processing testNest: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testNest", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testNest", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestMap implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testMap_args args = new testMap_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testMap", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testMap_result result = new testMap_result();
				try {
					result.success = handler.testMap(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testMap", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testMap", "Internal error processing testMap: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testMap", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testMap", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestStringMap implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testStringMap_args args = new testStringMap_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testStringMap", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testStringMap_result result = new testStringMap_result();
				try {
					result.success = handler.testStringMap(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testStringMap", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testStringMap", "Internal error processing testStringMap: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testStringMap", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testStringMap", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestSet implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testSet_args args = new testSet_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testSet", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testSet_result result = new testSet_result();
				try {
					result.success = handler.testSet(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testSet", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testSet", "Internal error processing testSet: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testSet", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testSet", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestList implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testList_args args = new testList_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testList", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testList_result result = new testList_result();
				try {
					result.success = handler.testList(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testList", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testList", "Internal error processing testList: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testList", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testList", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestEnum implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testEnum_args args = new testEnum_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testEnum", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testEnum_result result = new testEnum_result();
				try {
					result.success = handler.testEnum(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testEnum", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testEnum", "Internal error processing testEnum: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testEnum", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testEnum", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestTypedef implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testTypedef_args args = new testTypedef_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testTypedef", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testTypedef_result result = new testTypedef_result();
				try {
					result.success = handler.testTypedef(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testTypedef", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testTypedef", "Internal error processing testTypedef: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testTypedef", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testTypedef", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestMapMap implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testMapMap_args args = new testMapMap_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testMapMap", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testMapMap_result result = new testMapMap_result();
				try {
					result.success = handler.testMapMap(ctx, args.hello);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testMapMap", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testMapMap", "Internal error processing testMapMap: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testMapMap", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testMapMap", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestUppercaseMethod implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				TestUppercaseMethod_args args = new TestUppercaseMethod_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "TestUppercaseMethod", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				TestUppercaseMethod_result result = new TestUppercaseMethod_result();
				try {
					result.success = handler.TestUppercaseMethod(ctx, args.thing);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testUppercaseMethod", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testUppercaseMethod", "Internal error processing TestUppercaseMethod: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testUppercaseMethod", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testUppercaseMethod", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestInsanity implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testInsanity_args args = new testInsanity_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testInsanity", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testInsanity_result result = new testInsanity_result();
				try {
					result.success = handler.testInsanity(ctx, args.argument);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testInsanity", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testInsanity", "Internal error processing testInsanity: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testInsanity", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testInsanity", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestMulti implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testMulti_args args = new testMulti_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testMulti", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testMulti_result result = new testMulti_result();
				try {
					result.success = handler.testMulti(ctx, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testMulti", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testMulti", "Internal error processing testMulti: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testMulti", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testMulti", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestException implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testException_args args = new testException_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testException", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testException_result result = new testException_result();
				try {
					handler.testException(ctx, args.arg);
				} catch (Xception err1) {
					result.err1 = err1;
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testException", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testException", "Internal error processing testException: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testException", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testException", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestMultiException implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testMultiException_args args = new testMultiException_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testMultiException", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testMultiException_result result = new testMultiException_result();
				try {
					result.success = handler.testMultiException(ctx, args.arg0, args.arg1);
					result.setSuccessIsSet(true);
				} catch (Xception err1) {
					result.err1 = err1;
				} catch (Xception2 err2) {
					result.err2 = err2;
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testMultiException", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testMultiException", "Internal error processing testMultiException: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testMultiException", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testMultiException", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestUncaughtException implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testUncaughtException_args args = new testUncaughtException_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testUncaughtException", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testUncaughtException_result result = new testUncaughtException_result();
				try {
					handler.testUncaughtException(ctx);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testUncaughtException", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testUncaughtException", "Internal error processing testUncaughtException: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testUncaughtException", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testUncaughtException", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestUncheckedTApplicationException implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testUncheckedTApplicationException_args args = new testUncheckedTApplicationException_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testUncheckedTApplicationException", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testUncheckedTApplicationException_result result = new testUncheckedTApplicationException_result();
				try {
					handler.testUncheckedTApplicationException(ctx);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testUncheckedTApplicationException", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testUncheckedTApplicationException", "Internal error processing testUncheckedTApplicationException: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testUncheckedTApplicationException", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testUncheckedTApplicationException", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestRequestTooLarge implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testRequestTooLarge_args args = new testRequestTooLarge_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testRequestTooLarge", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testRequestTooLarge_result result = new testRequestTooLarge_result();
				try {
					handler.testRequestTooLarge(ctx, args.request);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testRequestTooLarge", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testRequestTooLarge", "Internal error processing testRequestTooLarge: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testRequestTooLarge", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testRequestTooLarge", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestResponseTooLarge implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testResponseTooLarge_args args = new testResponseTooLarge_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					synchronized (WRITE_LOCK) {
						e = writeApplicationException(ctx, oprot, TApplicationExceptionType.PROTOCOL_ERROR, "testResponseTooLarge", e.getMessage());
					}
					throw e;
				}

				iprot.readMessageEnd();
				testResponseTooLarge_result result = new testResponseTooLarge_result();
				try {
					result.success = handler.testResponseTooLarge(ctx, args.request);
					result.setSuccessIsSet(true);
				} catch (TApplicationException e) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("testResponseTooLarge", TMessageType.EXCEPTION, 0));
					e.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				} catch (TException e) {
					synchronized (WRITE_LOCK) {
						e = (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.INTERNAL_ERROR, "testResponseTooLarge", "Internal error processing testResponseTooLarge: " + e.getMessage()).initCause(e);
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					try {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("testResponseTooLarge", TMessageType.REPLY, 0));
						result.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					} catch (TTransportException e) {
						if (e.getType() == TTransportExceptionType.REQUEST_TOO_LARGE) {
							throw (TApplicationException) writeApplicationException(ctx, oprot, TApplicationExceptionType.RESPONSE_TOO_LARGE, "testResponseTooLarge", "response too large: " + e.getMessage()).initCause(e);
						}
						throw e;
					}
				}
			}
		}

		private class TestOneway implements FProcessorFunction {

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				testOneway_args args = new testOneway_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					throw e;
				}

				iprot.readMessageEnd();
				handler.testOneway(ctx, args.millisecondsToSleep);
			}
		}

	}

	public static class testVoid_args implements org.apache.thrift.TBase<testVoid_args, testVoid_args._Fields>, java.io.Serializable, Cloneable, Comparable<testVoid_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testVoid_args");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testVoid_args() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testVoid_args(testVoid_args other) {
		}

		public testVoid_args deepCopy() {
			return new testVoid_args(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testVoid_args)
				return this.equals((testVoid_args)that);
			return false;
		}

		public boolean equals(testVoid_args that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testVoid_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testVoid_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testVoid_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testVoid_args(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testVoid_argsStandardScheme extends StandardScheme<testVoid_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testVoid_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testVoid_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testVoid_result implements org.apache.thrift.TBase<testVoid_result, testVoid_result._Fields>, java.io.Serializable, Cloneable, Comparable<testVoid_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testVoid_result");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testVoid_result() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testVoid_result(testVoid_result other) {
		}

		public testVoid_result deepCopy() {
			return new testVoid_result(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testVoid_result)
				return this.equals((testVoid_result)that);
			return false;
		}

		public boolean equals(testVoid_result that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testVoid_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testVoid_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testVoid_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testVoid_result(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testVoid_resultStandardScheme extends StandardScheme<testVoid_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testVoid_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testVoid_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testString_args implements org.apache.thrift.TBase<testString_args, testString_args._Fields>, java.io.Serializable, Cloneable, Comparable<testString_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testString_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.STRING, (short)1);

		public String thing; // required
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testString_args() {
		}

		public testString_args(
			String thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testString_args(testString_args other) {
			if (other.isSetThing()) {
				this.thing = other.thing;
			}
		}

		public testString_args deepCopy() {
			return new testString_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public String getThing() {
			return this.thing;
		}

		public testString_args setThing(String thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((String)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testString_args)
				return this.equals((testString_args)that);
			return false;
		}

		public boolean equals(testString_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testString_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testString_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testString_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testString_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			if (thing == null) {
				throw new org.apache.thrift.protocol.TProtocolException("Required field 'thing' is not present in struct 'testString_args'");
			}
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testString_argsStandardScheme extends StandardScheme<testString_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testString_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.thing = iprot.readString();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testString_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					String elem29 = struct.thing;
					oprot.writeString(elem29);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testString_result implements org.apache.thrift.TBase<testString_result, testString_result._Fields>, java.io.Serializable, Cloneable, Comparable<testString_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testString_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);

		public String success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testString_result() {
		}

		public testString_result(
			String success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testString_result(testString_result other) {
			if (other.isSetSuccess()) {
				this.success = other.success;
			}
		}

		public testString_result deepCopy() {
			return new testString_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public String getSuccess() {
			return this.success;
		}

		public testString_result setSuccess(String success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((String)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testString_result)
				return this.equals((testString_result)that);
			return false;
		}

		public boolean equals(testString_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testString_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testString_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testString_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testString_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testString_resultStandardScheme extends StandardScheme<testString_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testString_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.success = iprot.readString();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testString_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					String elem30 = struct.success;
					oprot.writeString(elem30);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testBool_args implements org.apache.thrift.TBase<testBool_args, testBool_args._Fields>, java.io.Serializable, Cloneable, Comparable<testBool_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testBool_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.BOOL, (short)1);

		public boolean thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testBool_args() {
		}

		public testBool_args(
			boolean thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testBool_args(testBool_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testBool_args deepCopy() {
			return new testBool_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = false;

		}

		public boolean isThing() {
			return this.thing;
		}

		public testBool_args setThing(boolean thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Boolean)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return isThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testBool_args)
				return this.equals((testBool_args)that);
			return false;
		}

		public boolean equals(testBool_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testBool_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBool_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBool_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testBool_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testBool_argsStandardScheme extends StandardScheme<testBool_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testBool_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
								struct.thing = iprot.readBool();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testBool_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				boolean elem31 = struct.thing;
				oprot.writeBool(elem31);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testBool_result implements org.apache.thrift.TBase<testBool_result, testBool_result._Fields>, java.io.Serializable, Cloneable, Comparable<testBool_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testBool_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);

		public boolean success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testBool_result() {
		}

		public testBool_result(
			boolean success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testBool_result(testBool_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testBool_result deepCopy() {
			return new testBool_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = false;

		}

		public boolean isSuccess() {
			return this.success;
		}

		public testBool_result setSuccess(boolean success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Boolean)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return isSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testBool_result)
				return this.equals((testBool_result)that);
			return false;
		}

		public boolean equals(testBool_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testBool_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBool_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBool_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testBool_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testBool_resultStandardScheme extends StandardScheme<testBool_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testBool_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
								struct.success = iprot.readBool();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testBool_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					boolean elem32 = struct.success;
					oprot.writeBool(elem32);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testByte_args implements org.apache.thrift.TBase<testByte_args, testByte_args._Fields>, java.io.Serializable, Cloneable, Comparable<testByte_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testByte_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.BYTE, (short)1);

		public byte thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testByte_args() {
		}

		public testByte_args(
			byte thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testByte_args(testByte_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testByte_args deepCopy() {
			return new testByte_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = (byte)0;

		}

		public byte getThing() {
			return this.thing;
		}

		public testByte_args setThing(byte thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Byte)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testByte_args)
				return this.equals((testByte_args)that);
			return false;
		}

		public boolean equals(testByte_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testByte_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testByte_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testByte_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testByte_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testByte_argsStandardScheme extends StandardScheme<testByte_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testByte_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {
								struct.thing = iprot.readByte();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testByte_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				byte elem33 = struct.thing;
				oprot.writeByte(elem33);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testByte_result implements org.apache.thrift.TBase<testByte_result, testByte_result._Fields>, java.io.Serializable, Cloneable, Comparable<testByte_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testByte_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BYTE, (short)0);

		public byte success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testByte_result() {
		}

		public testByte_result(
			byte success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testByte_result(testByte_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testByte_result deepCopy() {
			return new testByte_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = (byte)0;

		}

		public byte getSuccess() {
			return this.success;
		}

		public testByte_result setSuccess(byte success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Byte)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testByte_result)
				return this.equals((testByte_result)that);
			return false;
		}

		public boolean equals(testByte_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testByte_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testByte_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testByte_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testByte_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testByte_resultStandardScheme extends StandardScheme<testByte_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testByte_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {
								struct.success = iprot.readByte();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testByte_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					byte elem34 = struct.success;
					oprot.writeByte(elem34);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testI32_args implements org.apache.thrift.TBase<testI32_args, testI32_args._Fields>, java.io.Serializable, Cloneable, Comparable<testI32_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testI32_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.I32, (short)1);

		public int thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testI32_args() {
		}

		public testI32_args(
			int thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testI32_args(testI32_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testI32_args deepCopy() {
			return new testI32_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = 0;

		}

		public int getThing() {
			return this.thing;
		}

		public testI32_args setThing(int thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Integer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testI32_args)
				return this.equals((testI32_args)that);
			return false;
		}

		public boolean equals(testI32_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testI32_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI32_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI32_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testI32_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testI32_argsStandardScheme extends StandardScheme<testI32_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testI32_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.thing = iprot.readI32();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testI32_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				int elem35 = struct.thing;
				oprot.writeI32(elem35);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testI32_result implements org.apache.thrift.TBase<testI32_result, testI32_result._Fields>, java.io.Serializable, Cloneable, Comparable<testI32_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testI32_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);

		public int success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testI32_result() {
		}

		public testI32_result(
			int success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testI32_result(testI32_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testI32_result deepCopy() {
			return new testI32_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = 0;

		}

		public int getSuccess() {
			return this.success;
		}

		public testI32_result setSuccess(int success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Integer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testI32_result)
				return this.equals((testI32_result)that);
			return false;
		}

		public boolean equals(testI32_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testI32_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI32_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI32_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testI32_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testI32_resultStandardScheme extends StandardScheme<testI32_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testI32_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.success = iprot.readI32();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testI32_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					int elem36 = struct.success;
					oprot.writeI32(elem36);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testI64_args implements org.apache.thrift.TBase<testI64_args, testI64_args._Fields>, java.io.Serializable, Cloneable, Comparable<testI64_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testI64_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.I64, (short)1);

		public long thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testI64_args() {
		}

		public testI64_args(
			long thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testI64_args(testI64_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testI64_args deepCopy() {
			return new testI64_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = 0L;

		}

		public long getThing() {
			return this.thing;
		}

		public testI64_args setThing(long thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Long)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testI64_args)
				return this.equals((testI64_args)that);
			return false;
		}

		public boolean equals(testI64_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testI64_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI64_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI64_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testI64_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testI64_argsStandardScheme extends StandardScheme<testI64_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testI64_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.thing = iprot.readI64();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testI64_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				long elem37 = struct.thing;
				oprot.writeI64(elem37);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testI64_result implements org.apache.thrift.TBase<testI64_result, testI64_result._Fields>, java.io.Serializable, Cloneable, Comparable<testI64_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testI64_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I64, (short)0);

		public long success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testI64_result() {
		}

		public testI64_result(
			long success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testI64_result(testI64_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testI64_result deepCopy() {
			return new testI64_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = 0L;

		}

		public long getSuccess() {
			return this.success;
		}

		public testI64_result setSuccess(long success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Long)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testI64_result)
				return this.equals((testI64_result)that);
			return false;
		}

		public boolean equals(testI64_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testI64_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI64_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testI64_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testI64_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testI64_resultStandardScheme extends StandardScheme<testI64_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testI64_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.success = iprot.readI64();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testI64_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					long elem38 = struct.success;
					oprot.writeI64(elem38);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testDouble_args implements org.apache.thrift.TBase<testDouble_args, testDouble_args._Fields>, java.io.Serializable, Cloneable, Comparable<testDouble_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testDouble_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.DOUBLE, (short)1);

		public double thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testDouble_args() {
		}

		public testDouble_args(
			double thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testDouble_args(testDouble_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testDouble_args deepCopy() {
			return new testDouble_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = 0.0;

		}

		public double getThing() {
			return this.thing;
		}

		public testDouble_args setThing(double thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Double)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testDouble_args)
				return this.equals((testDouble_args)that);
			return false;
		}

		public boolean equals(testDouble_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testDouble_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testDouble_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testDouble_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testDouble_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testDouble_argsStandardScheme extends StandardScheme<testDouble_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testDouble_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
								struct.thing = iprot.readDouble();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testDouble_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				double elem39 = struct.thing;
				oprot.writeDouble(elem39);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testDouble_result implements org.apache.thrift.TBase<testDouble_result, testDouble_result._Fields>, java.io.Serializable, Cloneable, Comparable<testDouble_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testDouble_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.DOUBLE, (short)0);

		public double success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testDouble_result() {
		}

		public testDouble_result(
			double success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testDouble_result(testDouble_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testDouble_result deepCopy() {
			return new testDouble_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = 0.0;

		}

		public double getSuccess() {
			return this.success;
		}

		public testDouble_result setSuccess(double success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Double)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testDouble_result)
				return this.equals((testDouble_result)that);
			return false;
		}

		public boolean equals(testDouble_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testDouble_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testDouble_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testDouble_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testDouble_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testDouble_resultStandardScheme extends StandardScheme<testDouble_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testDouble_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
								struct.success = iprot.readDouble();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testDouble_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					double elem40 = struct.success;
					oprot.writeDouble(elem40);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testBinary_args implements org.apache.thrift.TBase<testBinary_args, testBinary_args._Fields>, java.io.Serializable, Cloneable, Comparable<testBinary_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testBinary_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.STRING, (short)1);

		public java.nio.ByteBuffer thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testBinary_args() {
		}

		public testBinary_args(
			java.nio.ByteBuffer thing) {
			this();
			this.thing = org.apache.thrift.TBaseHelper.copyBinary(thing);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testBinary_args(testBinary_args other) {
			if (other.isSetThing()) {
				this.thing = org.apache.thrift.TBaseHelper.copyBinary(other.thing);
			}
		}

		public testBinary_args deepCopy() {
			return new testBinary_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public byte[] getThing() {
			setThing(org.apache.thrift.TBaseHelper.rightSize(thing));
			return thing == null ? null : thing.array();
		}

		public java.nio.ByteBuffer bufferForThing() {
			return org.apache.thrift.TBaseHelper.copyBinary(thing);
		}

		public testBinary_args setThing(byte[] thing) {
			this.thing = thing == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(Arrays.copyOf(thing, thing.length));
			return this;
		}

		public testBinary_args setThing(java.nio.ByteBuffer thing) {
			this.thing = org.apache.thrift.TBaseHelper.copyBinary(thing);
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((java.nio.ByteBuffer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testBinary_args)
				return this.equals((testBinary_args)that);
			return false;
		}

		public boolean equals(testBinary_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testBinary_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBinary_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBinary_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testBinary_args(");
			boolean first = true;

			sb.append("thing:");
			if (this.thing == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.thing, sb);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testBinary_argsStandardScheme extends StandardScheme<testBinary_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testBinary_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.thing = iprot.readBinary();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testBinary_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					java.nio.ByteBuffer elem41 = struct.thing;
					oprot.writeBinary(elem41);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testBinary_result implements org.apache.thrift.TBase<testBinary_result, testBinary_result._Fields>, java.io.Serializable, Cloneable, Comparable<testBinary_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testBinary_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);

		public java.nio.ByteBuffer success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testBinary_result() {
		}

		public testBinary_result(
			java.nio.ByteBuffer success) {
			this();
			this.success = org.apache.thrift.TBaseHelper.copyBinary(success);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testBinary_result(testBinary_result other) {
			if (other.isSetSuccess()) {
				this.success = org.apache.thrift.TBaseHelper.copyBinary(other.success);
			}
		}

		public testBinary_result deepCopy() {
			return new testBinary_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public byte[] getSuccess() {
			setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));
			return success == null ? null : success.array();
		}

		public java.nio.ByteBuffer bufferForSuccess() {
			return org.apache.thrift.TBaseHelper.copyBinary(success);
		}

		public testBinary_result setSuccess(byte[] success) {
			this.success = success == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(Arrays.copyOf(success, success.length));
			return this;
		}

		public testBinary_result setSuccess(java.nio.ByteBuffer success) {
			this.success = org.apache.thrift.TBaseHelper.copyBinary(success);
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.nio.ByteBuffer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testBinary_result)
				return this.equals((testBinary_result)that);
			return false;
		}

		public boolean equals(testBinary_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testBinary_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBinary_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testBinary_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testBinary_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.success, sb);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testBinary_resultStandardScheme extends StandardScheme<testBinary_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testBinary_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.success = iprot.readBinary();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testBinary_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					java.nio.ByteBuffer elem42 = struct.success;
					oprot.writeBinary(elem42);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testStruct_args implements org.apache.thrift.TBase<testStruct_args, testStruct_args._Fields>, java.io.Serializable, Cloneable, Comparable<testStruct_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testStruct_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.STRUCT, (short)1);

		public Xtruct thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testStruct_args() {
		}

		public testStruct_args(
			Xtruct thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testStruct_args(testStruct_args other) {
			if (other.isSetThing()) {
				this.thing = new Xtruct(other.thing);
			}
		}

		public testStruct_args deepCopy() {
			return new testStruct_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public Xtruct getThing() {
			return this.thing;
		}

		public testStruct_args setThing(Xtruct thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Xtruct)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testStruct_args)
				return this.equals((testStruct_args)that);
			return false;
		}

		public boolean equals(testStruct_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testStruct_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStruct_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStruct_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testStruct_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (thing != null) {
				thing.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testStruct_argsStandardScheme extends StandardScheme<testStruct_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testStruct_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.thing = new Xtruct();
								struct.thing.read(iprot);
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testStruct_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					struct.thing.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testStruct_result implements org.apache.thrift.TBase<testStruct_result, testStruct_result._Fields>, java.io.Serializable, Cloneable, Comparable<testStruct_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testStruct_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);

		public Xtruct success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testStruct_result() {
		}

		public testStruct_result(
			Xtruct success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testStruct_result(testStruct_result other) {
			if (other.isSetSuccess()) {
				this.success = new Xtruct(other.success);
			}
		}

		public testStruct_result deepCopy() {
			return new testStruct_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public Xtruct getSuccess() {
			return this.success;
		}

		public testStruct_result setSuccess(Xtruct success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Xtruct)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testStruct_result)
				return this.equals((testStruct_result)that);
			return false;
		}

		public boolean equals(testStruct_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testStruct_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStruct_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStruct_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testStruct_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (success != null) {
				success.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testStruct_resultStandardScheme extends StandardScheme<testStruct_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testStruct_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.success = new Xtruct();
								struct.success.read(iprot);
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testStruct_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					struct.success.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testNest_args implements org.apache.thrift.TBase<testNest_args, testNest_args._Fields>, java.io.Serializable, Cloneable, Comparable<testNest_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testNest_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.STRUCT, (short)1);

		public Xtruct2 thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testNest_args() {
		}

		public testNest_args(
			Xtruct2 thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testNest_args(testNest_args other) {
			if (other.isSetThing()) {
				this.thing = new Xtruct2(other.thing);
			}
		}

		public testNest_args deepCopy() {
			return new testNest_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public Xtruct2 getThing() {
			return this.thing;
		}

		public testNest_args setThing(Xtruct2 thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Xtruct2)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testNest_args)
				return this.equals((testNest_args)that);
			return false;
		}

		public boolean equals(testNest_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testNest_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testNest_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testNest_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testNest_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (thing != null) {
				thing.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testNest_argsStandardScheme extends StandardScheme<testNest_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testNest_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.thing = new Xtruct2();
								struct.thing.read(iprot);
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testNest_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					struct.thing.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testNest_result implements org.apache.thrift.TBase<testNest_result, testNest_result._Fields>, java.io.Serializable, Cloneable, Comparable<testNest_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testNest_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);

		public Xtruct2 success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testNest_result() {
		}

		public testNest_result(
			Xtruct2 success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testNest_result(testNest_result other) {
			if (other.isSetSuccess()) {
				this.success = new Xtruct2(other.success);
			}
		}

		public testNest_result deepCopy() {
			return new testNest_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public Xtruct2 getSuccess() {
			return this.success;
		}

		public testNest_result setSuccess(Xtruct2 success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Xtruct2)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testNest_result)
				return this.equals((testNest_result)that);
			return false;
		}

		public boolean equals(testNest_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testNest_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testNest_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testNest_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testNest_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (success != null) {
				success.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testNest_resultStandardScheme extends StandardScheme<testNest_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testNest_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.success = new Xtruct2();
								struct.success.read(iprot);
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testNest_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					struct.success.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMap_args implements org.apache.thrift.TBase<testMap_args, testMap_args._Fields>, java.io.Serializable, Cloneable, Comparable<testMap_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMap_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.MAP, (short)1);

		public java.util.Map<Integer, Integer> thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMap_args() {
		}

		public testMap_args(
			java.util.Map<Integer, Integer> thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMap_args(testMap_args other) {
			if (other.isSetThing()) {
				this.thing = new HashMap<Integer,Integer>(other.thing);
			}
		}

		public testMap_args deepCopy() {
			return new testMap_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public int getThingSize() {
			return (this.thing == null) ? 0 : this.thing.size();
		}

		public void putToThing(int key, int val) {
			if (this.thing == null) {
				this.thing = new HashMap<Integer,Integer>();
			}
			this.thing.put(key, val);
		}

		public java.util.Map<Integer, Integer> getThing() {
			return this.thing;
		}

		public testMap_args setThing(java.util.Map<Integer, Integer> thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((java.util.Map<Integer, Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMap_args)
				return this.equals((testMap_args)that);
			return false;
		}

		public boolean equals(testMap_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMap_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMap_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMap_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMap_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMap_argsStandardScheme extends StandardScheme<testMap_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMap_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem45 = iprot.readMapBegin();
								struct.thing = new HashMap<Integer,Integer>(2*elem45.size);
								for (int elem46 = 0; elem46 < elem45.size; ++elem46) {
									int elem48 = iprot.readI32();
									int elem47 = iprot.readI32();
									struct.thing.put(elem48, elem47);
								}
								iprot.readMapEnd();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMap_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.I32, struct.thing.size()));
					for (Map.Entry<Integer, Integer> elem49 : struct.thing.entrySet()) {
						int elem50 = elem49.getKey();
						oprot.writeI32(elem50);
						int elem51 = elem49.getValue();
						oprot.writeI32(elem51);
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMap_result implements org.apache.thrift.TBase<testMap_result, testMap_result._Fields>, java.io.Serializable, Cloneable, Comparable<testMap_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMap_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.MAP, (short)0);

		public java.util.Map<Integer, Integer> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMap_result() {
		}

		public testMap_result(
			java.util.Map<Integer, Integer> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMap_result(testMap_result other) {
			if (other.isSetSuccess()) {
				this.success = new HashMap<Integer,Integer>(other.success);
			}
		}

		public testMap_result deepCopy() {
			return new testMap_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(int key, int val) {
			if (this.success == null) {
				this.success = new HashMap<Integer,Integer>();
			}
			this.success.put(key, val);
		}

		public java.util.Map<Integer, Integer> getSuccess() {
			return this.success;
		}

		public testMap_result setSuccess(java.util.Map<Integer, Integer> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.Map<Integer, Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMap_result)
				return this.equals((testMap_result)that);
			return false;
		}

		public boolean equals(testMap_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMap_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMap_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMap_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMap_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMap_resultStandardScheme extends StandardScheme<testMap_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMap_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem54 = iprot.readMapBegin();
								struct.success = new HashMap<Integer,Integer>(2*elem54.size);
								for (int elem55 = 0; elem55 < elem54.size; ++elem55) {
									int elem57 = iprot.readI32();
									int elem56 = iprot.readI32();
									struct.success.put(elem57, elem56);
								}
								iprot.readMapEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMap_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.I32, struct.success.size()));
					for (Map.Entry<Integer, Integer> elem58 : struct.success.entrySet()) {
						int elem59 = elem58.getKey();
						oprot.writeI32(elem59);
						int elem60 = elem58.getValue();
						oprot.writeI32(elem60);
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testStringMap_args implements org.apache.thrift.TBase<testStringMap_args, testStringMap_args._Fields>, java.io.Serializable, Cloneable, Comparable<testStringMap_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testStringMap_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.MAP, (short)1);

		public java.util.Map<String, String> thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testStringMap_args() {
		}

		public testStringMap_args(
			java.util.Map<String, String> thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testStringMap_args(testStringMap_args other) {
			if (other.isSetThing()) {
				this.thing = new HashMap<String,String>(other.thing);
			}
		}

		public testStringMap_args deepCopy() {
			return new testStringMap_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public int getThingSize() {
			return (this.thing == null) ? 0 : this.thing.size();
		}

		public void putToThing(String key, String val) {
			if (this.thing == null) {
				this.thing = new HashMap<String,String>();
			}
			this.thing.put(key, val);
		}

		public java.util.Map<String, String> getThing() {
			return this.thing;
		}

		public testStringMap_args setThing(java.util.Map<String, String> thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((java.util.Map<String, String>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testStringMap_args)
				return this.equals((testStringMap_args)that);
			return false;
		}

		public boolean equals(testStringMap_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testStringMap_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStringMap_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStringMap_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testStringMap_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testStringMap_argsStandardScheme extends StandardScheme<testStringMap_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testStringMap_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem63 = iprot.readMapBegin();
								struct.thing = new HashMap<String,String>(2*elem63.size);
								for (int elem64 = 0; elem64 < elem63.size; ++elem64) {
									String elem66 = iprot.readString();
									String elem65 = iprot.readString();
									struct.thing.put(elem66, elem65);
								}
								iprot.readMapEnd();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testStringMap_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.thing.size()));
					for (Map.Entry<String, String> elem67 : struct.thing.entrySet()) {
						String elem68 = elem67.getKey();
						oprot.writeString(elem68);
						String elem69 = elem67.getValue();
						oprot.writeString(elem69);
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testStringMap_result implements org.apache.thrift.TBase<testStringMap_result, testStringMap_result._Fields>, java.io.Serializable, Cloneable, Comparable<testStringMap_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testStringMap_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.MAP, (short)0);

		public java.util.Map<String, String> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testStringMap_result() {
		}

		public testStringMap_result(
			java.util.Map<String, String> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testStringMap_result(testStringMap_result other) {
			if (other.isSetSuccess()) {
				this.success = new HashMap<String,String>(other.success);
			}
		}

		public testStringMap_result deepCopy() {
			return new testStringMap_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(String key, String val) {
			if (this.success == null) {
				this.success = new HashMap<String,String>();
			}
			this.success.put(key, val);
		}

		public java.util.Map<String, String> getSuccess() {
			return this.success;
		}

		public testStringMap_result setSuccess(java.util.Map<String, String> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.Map<String, String>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testStringMap_result)
				return this.equals((testStringMap_result)that);
			return false;
		}

		public boolean equals(testStringMap_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testStringMap_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStringMap_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testStringMap_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testStringMap_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testStringMap_resultStandardScheme extends StandardScheme<testStringMap_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testStringMap_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem72 = iprot.readMapBegin();
								struct.success = new HashMap<String,String>(2*elem72.size);
								for (int elem73 = 0; elem73 < elem72.size; ++elem73) {
									String elem75 = iprot.readString();
									String elem74 = iprot.readString();
									struct.success.put(elem75, elem74);
								}
								iprot.readMapEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testStringMap_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.success.size()));
					for (Map.Entry<String, String> elem76 : struct.success.entrySet()) {
						String elem77 = elem76.getKey();
						oprot.writeString(elem77);
						String elem78 = elem76.getValue();
						oprot.writeString(elem78);
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testSet_args implements org.apache.thrift.TBase<testSet_args, testSet_args._Fields>, java.io.Serializable, Cloneable, Comparable<testSet_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testSet_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.SET, (short)1);

		public java.util.Set<Integer> thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testSet_args() {
		}

		public testSet_args(
			java.util.Set<Integer> thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testSet_args(testSet_args other) {
			if (other.isSetThing()) {
				this.thing = new HashSet<Integer>(other.thing.size());
				for (int elem79 : other.thing) {
					int elem80 = elem79;
					this.thing.add(elem80);
				}
			}
		}

		public testSet_args deepCopy() {
			return new testSet_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public int getThingSize() {
			return (this.thing == null) ? 0 : this.thing.size();
		}

		public java.util.Iterator<Integer> getThingIterator() {
			return (this.thing == null) ? null : this.thing.iterator();
		}

		public void addToThing(int elem) {
			if (this.thing == null) {
				this.thing = new HashSet<Integer>();
			}
			this.thing.add(elem);
		}

		public java.util.Set<Integer> getThing() {
			return this.thing;
		}

		public testSet_args setThing(java.util.Set<Integer> thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((java.util.Set<Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testSet_args)
				return this.equals((testSet_args)that);
			return false;
		}

		public boolean equals(testSet_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testSet_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testSet_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testSet_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testSet_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testSet_argsStandardScheme extends StandardScheme<testSet_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testSet_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.SET) {
								org.apache.thrift.protocol.TSet elem81 = iprot.readSetBegin();
								struct.thing = new HashSet<Integer>(2*elem81.size);
								for (int elem82 = 0; elem82 < elem81.size; ++elem82) {
									int elem83 = iprot.readI32();
									struct.thing.add(elem83);
								}
								iprot.readSetEnd();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testSet_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, struct.thing.size()));
					for (int elem84 : struct.thing) {
						int elem85 = elem84;
						oprot.writeI32(elem85);
					}
					oprot.writeSetEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testSet_result implements org.apache.thrift.TBase<testSet_result, testSet_result._Fields>, java.io.Serializable, Cloneable, Comparable<testSet_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testSet_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.SET, (short)0);

		public java.util.Set<Integer> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testSet_result() {
		}

		public testSet_result(
			java.util.Set<Integer> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testSet_result(testSet_result other) {
			if (other.isSetSuccess()) {
				this.success = new HashSet<Integer>(other.success.size());
				for (int elem86 : other.success) {
					int elem87 = elem86;
					this.success.add(elem87);
				}
			}
		}

		public testSet_result deepCopy() {
			return new testSet_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<Integer> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(int elem) {
			if (this.success == null) {
				this.success = new HashSet<Integer>();
			}
			this.success.add(elem);
		}

		public java.util.Set<Integer> getSuccess() {
			return this.success;
		}

		public testSet_result setSuccess(java.util.Set<Integer> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.Set<Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testSet_result)
				return this.equals((testSet_result)that);
			return false;
		}

		public boolean equals(testSet_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testSet_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testSet_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testSet_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testSet_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testSet_resultStandardScheme extends StandardScheme<testSet_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testSet_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.SET) {
								org.apache.thrift.protocol.TSet elem88 = iprot.readSetBegin();
								struct.success = new HashSet<Integer>(2*elem88.size);
								for (int elem89 = 0; elem89 < elem88.size; ++elem89) {
									int elem90 = iprot.readI32();
									struct.success.add(elem90);
								}
								iprot.readSetEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testSet_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, struct.success.size()));
					for (int elem91 : struct.success) {
						int elem92 = elem91;
						oprot.writeI32(elem92);
					}
					oprot.writeSetEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testList_args implements org.apache.thrift.TBase<testList_args, testList_args._Fields>, java.io.Serializable, Cloneable, Comparable<testList_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testList_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.LIST, (short)1);

		public java.util.List<Integer> thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testList_args() {
		}

		public testList_args(
			java.util.List<Integer> thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testList_args(testList_args other) {
			if (other.isSetThing()) {
				this.thing = new ArrayList<Integer>(other.thing.size());
				for (int elem93 : other.thing) {
					int elem94 = elem93;
					this.thing.add(elem94);
				}
			}
		}

		public testList_args deepCopy() {
			return new testList_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public int getThingSize() {
			return (this.thing == null) ? 0 : this.thing.size();
		}

		public java.util.Iterator<Integer> getThingIterator() {
			return (this.thing == null) ? null : this.thing.iterator();
		}

		public void addToThing(int elem) {
			if (this.thing == null) {
				this.thing = new ArrayList<Integer>();
			}
			this.thing.add(elem);
		}

		public java.util.List<Integer> getThing() {
			return this.thing;
		}

		public testList_args setThing(java.util.List<Integer> thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((java.util.List<Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testList_args)
				return this.equals((testList_args)that);
			return false;
		}

		public boolean equals(testList_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testList_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testList_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testList_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testList_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testList_argsStandardScheme extends StandardScheme<testList_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testList_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
								org.apache.thrift.protocol.TList elem95 = iprot.readListBegin();
								struct.thing = new ArrayList<Integer>(elem95.size);
								for (int elem96 = 0; elem96 < elem95.size; ++elem96) {
									int elem97 = iprot.readI32();
									struct.thing.add(elem97);
								}
								iprot.readListEnd();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testList_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.thing.size()));
					for (int elem98 : struct.thing) {
						int elem99 = elem98;
						oprot.writeI32(elem99);
					}
					oprot.writeListEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testList_result implements org.apache.thrift.TBase<testList_result, testList_result._Fields>, java.io.Serializable, Cloneable, Comparable<testList_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testList_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.LIST, (short)0);

		public java.util.List<Integer> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testList_result() {
		}

		public testList_result(
			java.util.List<Integer> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testList_result(testList_result other) {
			if (other.isSetSuccess()) {
				this.success = new ArrayList<Integer>(other.success.size());
				for (int elem100 : other.success) {
					int elem101 = elem100;
					this.success.add(elem101);
				}
			}
		}

		public testList_result deepCopy() {
			return new testList_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public java.util.Iterator<Integer> getSuccessIterator() {
			return (this.success == null) ? null : this.success.iterator();
		}

		public void addToSuccess(int elem) {
			if (this.success == null) {
				this.success = new ArrayList<Integer>();
			}
			this.success.add(elem);
		}

		public java.util.List<Integer> getSuccess() {
			return this.success;
		}

		public testList_result setSuccess(java.util.List<Integer> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.List<Integer>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testList_result)
				return this.equals((testList_result)that);
			return false;
		}

		public boolean equals(testList_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testList_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testList_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testList_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testList_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testList_resultStandardScheme extends StandardScheme<testList_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testList_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
								org.apache.thrift.protocol.TList elem102 = iprot.readListBegin();
								struct.success = new ArrayList<Integer>(elem102.size);
								for (int elem103 = 0; elem103 < elem102.size; ++elem103) {
									int elem104 = iprot.readI32();
									struct.success.add(elem104);
								}
								iprot.readListEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testList_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.success.size()));
					for (int elem105 : struct.success) {
						int elem106 = elem105;
						oprot.writeI32(elem106);
					}
					oprot.writeListEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testEnum_args implements org.apache.thrift.TBase<testEnum_args, testEnum_args._Fields>, java.io.Serializable, Cloneable, Comparable<testEnum_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testEnum_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.I32, (short)1);

		public Numberz thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testEnum_args() {
		}

		public testEnum_args(
			Numberz thing) {
			this();
			this.thing = thing;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testEnum_args(testEnum_args other) {
			if (other.isSetThing()) {
				this.thing = other.thing;
			}
		}

		public testEnum_args deepCopy() {
			return new testEnum_args(this);
		}

		@Override
		public void clear() {
			this.thing = null;

		}

		public Numberz getThing() {
			return this.thing;
		}

		public testEnum_args setThing(Numberz thing) {
			this.thing = thing;
			return this;
		}

		public void unsetThing() {
			this.thing = null;
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return this.thing != null;
		}

		public void setThingIsSet(boolean value) {
			if (!value) {
				this.thing = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Numberz)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testEnum_args)
				return this.equals((testEnum_args)that);
			return false;
		}

		public boolean equals(testEnum_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.thing, that.thing))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true && (isSetThing());
			list.add(present_thing);
			if (present_thing)
				list.add(thing.getValue());

			return list.hashCode();
		}

		@Override
		public int compareTo(testEnum_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testEnum_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testEnum_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testEnum_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testEnum_argsStandardScheme extends StandardScheme<testEnum_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testEnum_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.thing = Numberz.findByValue(iprot.readI32());
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testEnum_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetThing()) {
					oprot.writeFieldBegin(THING_FIELD_DESC);
					Numberz elem107 = struct.thing;
					oprot.writeI32(elem107.getValue());
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testEnum_result implements org.apache.thrift.TBase<testEnum_result, testEnum_result._Fields>, java.io.Serializable, Cloneable, Comparable<testEnum_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testEnum_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);

		public Numberz success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testEnum_result() {
		}

		public testEnum_result(
			Numberz success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testEnum_result(testEnum_result other) {
			if (other.isSetSuccess()) {
				this.success = other.success;
			}
		}

		public testEnum_result deepCopy() {
			return new testEnum_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public Numberz getSuccess() {
			return this.success;
		}

		public testEnum_result setSuccess(Numberz success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Numberz)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testEnum_result)
				return this.equals((testEnum_result)that);
			return false;
		}

		public boolean equals(testEnum_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success.getValue());

			return list.hashCode();
		}

		@Override
		public int compareTo(testEnum_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testEnum_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testEnum_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testEnum_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testEnum_resultStandardScheme extends StandardScheme<testEnum_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testEnum_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.success = Numberz.findByValue(iprot.readI32());
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testEnum_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					Numberz elem108 = struct.success;
					oprot.writeI32(elem108.getValue());
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testTypedef_args implements org.apache.thrift.TBase<testTypedef_args, testTypedef_args._Fields>, java.io.Serializable, Cloneable, Comparable<testTypedef_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testTypedef_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.I64, (short)1);

		public long thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testTypedef_args() {
		}

		public testTypedef_args(
			long thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testTypedef_args(testTypedef_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public testTypedef_args deepCopy() {
			return new testTypedef_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = 0L;

		}

		public long getThing() {
			return this.thing;
		}

		public testTypedef_args setThing(long thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Long)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return getThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testTypedef_args)
				return this.equals((testTypedef_args)that);
			return false;
		}

		public boolean equals(testTypedef_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(testTypedef_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testTypedef_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testTypedef_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testTypedef_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testTypedef_argsStandardScheme extends StandardScheme<testTypedef_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testTypedef_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.thing = iprot.readI64();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testTypedef_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				long elem109 = struct.thing;
				oprot.writeI64(elem109);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testTypedef_result implements org.apache.thrift.TBase<testTypedef_result, testTypedef_result._Fields>, java.io.Serializable, Cloneable, Comparable<testTypedef_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testTypedef_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I64, (short)0);

		public long success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testTypedef_result() {
		}

		public testTypedef_result(
			long success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testTypedef_result(testTypedef_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public testTypedef_result deepCopy() {
			return new testTypedef_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = 0L;

		}

		public long getSuccess() {
			return this.success;
		}

		public testTypedef_result setSuccess(long success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Long)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testTypedef_result)
				return this.equals((testTypedef_result)that);
			return false;
		}

		public boolean equals(testTypedef_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testTypedef_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testTypedef_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testTypedef_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testTypedef_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testTypedef_resultStandardScheme extends StandardScheme<testTypedef_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testTypedef_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.success = iprot.readI64();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testTypedef_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					long elem110 = struct.success;
					oprot.writeI64(elem110);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMapMap_args implements org.apache.thrift.TBase<testMapMap_args, testMapMap_args._Fields>, java.io.Serializable, Cloneable, Comparable<testMapMap_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMapMap_args");

		private static final org.apache.thrift.protocol.TField HELLO_FIELD_DESC = new org.apache.thrift.protocol.TField("hello", org.apache.thrift.protocol.TType.I32, (short)1);

		public int hello;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			HELLO((short)1, "hello")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // HELLO
						return HELLO;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __HELLO_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testMapMap_args() {
		}

		public testMapMap_args(
			int hello) {
			this();
			this.hello = hello;
			setHelloIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMapMap_args(testMapMap_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.hello = other.hello;
		}

		public testMapMap_args deepCopy() {
			return new testMapMap_args(this);
		}

		@Override
		public void clear() {
			setHelloIsSet(false);
			this.hello = 0;

		}

		public int getHello() {
			return this.hello;
		}

		public testMapMap_args setHello(int hello) {
			this.hello = hello;
			setHelloIsSet(true);
			return this;
		}

		public void unsetHello() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HELLO_ISSET_ID);
		}

		/** Returns true if field hello is set (has been assigned a value) and false otherwise */
		public boolean isSetHello() {
			return EncodingUtils.testBit(__isset_bitfield, __HELLO_ISSET_ID);
		}

		public void setHelloIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HELLO_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case HELLO:
				if (value == null) {
					unsetHello();
				} else {
					setHello((Integer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case HELLO:
				return getHello();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case HELLO:
				return isSetHello();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMapMap_args)
				return this.equals((testMapMap_args)that);
			return false;
		}

		public boolean equals(testMapMap_args that) {
			if (that == null)
				return false;
			if (this.hello != that.hello)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_hello = true;
			list.add(present_hello);
			if (present_hello)
				list.add(hello);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMapMap_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetHello(), other.isSetHello());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetHello()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hello, other.hello);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMapMap_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMapMap_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMapMap_args(");
			boolean first = true;

			sb.append("hello:");
			sb.append(this.hello);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMapMap_argsStandardScheme extends StandardScheme<testMapMap_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMapMap_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // HELLO
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.hello = iprot.readI32();
								struct.setHelloIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMapMap_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(HELLO_FIELD_DESC);
				int elem111 = struct.hello;
				oprot.writeI32(elem111);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMapMap_result implements org.apache.thrift.TBase<testMapMap_result, testMapMap_result._Fields>, java.io.Serializable, Cloneable, Comparable<testMapMap_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMapMap_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.MAP, (short)0);

		public java.util.Map<Integer, java.util.Map<Integer, Integer>> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMapMap_result() {
		}

		public testMapMap_result(
			java.util.Map<Integer, java.util.Map<Integer, Integer>> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMapMap_result(testMapMap_result other) {
			if (other.isSetSuccess()) {
				this.success = new HashMap<Integer,java.util.Map<Integer, Integer>>(other.success.size());
				for (Map.Entry<Integer, java.util.Map<Integer, Integer>> elem112 : other.success.entrySet()) {
					int elem114 = elem112.getKey();
					java.util.Map<Integer, Integer> elem113 = new HashMap<Integer,Integer>(elem112.getValue());
					this.success.put(elem114, elem113);
				}
			}
		}

		public testMapMap_result deepCopy() {
			return new testMapMap_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(int key, java.util.Map<Integer, Integer> val) {
			if (this.success == null) {
				this.success = new HashMap<Integer,java.util.Map<Integer, Integer>>();
			}
			this.success.put(key, val);
		}

		public java.util.Map<Integer, java.util.Map<Integer, Integer>> getSuccess() {
			return this.success;
		}

		public testMapMap_result setSuccess(java.util.Map<Integer, java.util.Map<Integer, Integer>> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.Map<Integer, java.util.Map<Integer, Integer>>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMapMap_result)
				return this.equals((testMapMap_result)that);
			return false;
		}

		public boolean equals(testMapMap_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMapMap_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMapMap_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMapMap_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMapMap_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMapMap_resultStandardScheme extends StandardScheme<testMapMap_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMapMap_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem117 = iprot.readMapBegin();
								struct.success = new HashMap<Integer,java.util.Map<Integer, Integer>>(2*elem117.size);
								for (int elem118 = 0; elem118 < elem117.size; ++elem118) {
									int elem124 = iprot.readI32();
									org.apache.thrift.protocol.TMap elem120 = iprot.readMapBegin();
									java.util.Map<Integer, Integer> elem119 = new HashMap<Integer,Integer>(2*elem120.size);
									for (int elem121 = 0; elem121 < elem120.size; ++elem121) {
										int elem123 = iprot.readI32();
										int elem122 = iprot.readI32();
										elem119.put(elem123, elem122);
									}
									iprot.readMapEnd();
									struct.success.put(elem124, elem119);
								}
								iprot.readMapEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMapMap_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.MAP, struct.success.size()));
					for (Map.Entry<Integer, java.util.Map<Integer, Integer>> elem125 : struct.success.entrySet()) {
						int elem126 = elem125.getKey();
						oprot.writeI32(elem126);
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.I32, elem125.getValue().size()));
						for (Map.Entry<Integer, Integer> elem127 : elem125.getValue().entrySet()) {
							int elem128 = elem127.getKey();
							oprot.writeI32(elem128);
							int elem129 = elem127.getValue();
							oprot.writeI32(elem129);
						}
						oprot.writeMapEnd();
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class TestUppercaseMethod_args implements org.apache.thrift.TBase<TestUppercaseMethod_args, TestUppercaseMethod_args._Fields>, java.io.Serializable, Cloneable, Comparable<TestUppercaseMethod_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TestUppercaseMethod_args");

		private static final org.apache.thrift.protocol.TField THING_FIELD_DESC = new org.apache.thrift.protocol.TField("thing", org.apache.thrift.protocol.TType.BOOL, (short)1);

		public boolean thing;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			THING((short)1, "thing")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // THING
						return THING;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __THING_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public TestUppercaseMethod_args() {
		}

		public TestUppercaseMethod_args(
			boolean thing) {
			this();
			this.thing = thing;
			setThingIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public TestUppercaseMethod_args(TestUppercaseMethod_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.thing = other.thing;
		}

		public TestUppercaseMethod_args deepCopy() {
			return new TestUppercaseMethod_args(this);
		}

		@Override
		public void clear() {
			setThingIsSet(false);
			this.thing = false;

		}

		public boolean isThing() {
			return this.thing;
		}

		public TestUppercaseMethod_args setThing(boolean thing) {
			this.thing = thing;
			setThingIsSet(true);
			return this;
		}

		public void unsetThing() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __THING_ISSET_ID);
		}

		/** Returns true if field thing is set (has been assigned a value) and false otherwise */
		public boolean isSetThing() {
			return EncodingUtils.testBit(__isset_bitfield, __THING_ISSET_ID);
		}

		public void setThingIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __THING_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case THING:
				if (value == null) {
					unsetThing();
				} else {
					setThing((Boolean)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case THING:
				return isThing();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case THING:
				return isSetThing();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof TestUppercaseMethod_args)
				return this.equals((TestUppercaseMethod_args)that);
			return false;
		}

		public boolean equals(TestUppercaseMethod_args that) {
			if (that == null)
				return false;
			if (this.thing != that.thing)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_thing = true;
			list.add(present_thing);
			if (present_thing)
				list.add(thing);

			return list.hashCode();
		}

		@Override
		public int compareTo(TestUppercaseMethod_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetThing(), other.isSetThing());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetThing()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.thing, other.thing);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new TestUppercaseMethod_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new TestUppercaseMethod_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("TestUppercaseMethod_args(");
			boolean first = true;

			sb.append("thing:");
			sb.append(this.thing);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class TestUppercaseMethod_argsStandardScheme extends StandardScheme<TestUppercaseMethod_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, TestUppercaseMethod_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // THING
							if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
								struct.thing = iprot.readBool();
								struct.setThingIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, TestUppercaseMethod_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(THING_FIELD_DESC);
				boolean elem130 = struct.thing;
				oprot.writeBool(elem130);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class TestUppercaseMethod_result implements org.apache.thrift.TBase<TestUppercaseMethod_result, TestUppercaseMethod_result._Fields>, java.io.Serializable, Cloneable, Comparable<TestUppercaseMethod_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TestUppercaseMethod_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);

		public boolean success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public TestUppercaseMethod_result() {
		}

		public TestUppercaseMethod_result(
			boolean success) {
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public TestUppercaseMethod_result(TestUppercaseMethod_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public TestUppercaseMethod_result deepCopy() {
			return new TestUppercaseMethod_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = false;

		}

		public boolean isSuccess() {
			return this.success;
		}

		public TestUppercaseMethod_result setSuccess(boolean success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Boolean)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return isSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof TestUppercaseMethod_result)
				return this.equals((TestUppercaseMethod_result)that);
			return false;
		}

		public boolean equals(TestUppercaseMethod_result that) {
			if (that == null)
				return false;
			if (this.success != that.success)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(TestUppercaseMethod_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new TestUppercaseMethod_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new TestUppercaseMethod_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("TestUppercaseMethod_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class TestUppercaseMethod_resultStandardScheme extends StandardScheme<TestUppercaseMethod_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, TestUppercaseMethod_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
								struct.success = iprot.readBool();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, TestUppercaseMethod_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					boolean elem131 = struct.success;
					oprot.writeBool(elem131);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testInsanity_args implements org.apache.thrift.TBase<testInsanity_args, testInsanity_args._Fields>, java.io.Serializable, Cloneable, Comparable<testInsanity_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testInsanity_args");

		private static final org.apache.thrift.protocol.TField ARGUMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("argument", org.apache.thrift.protocol.TType.STRUCT, (short)1);

		public Insanity argument;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			ARGUMENT((short)1, "argument")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // ARGUMENT
						return ARGUMENT;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testInsanity_args() {
		}

		public testInsanity_args(
			Insanity argument) {
			this();
			this.argument = argument;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testInsanity_args(testInsanity_args other) {
			if (other.isSetArgument()) {
				this.argument = new Insanity(other.argument);
			}
		}

		public testInsanity_args deepCopy() {
			return new testInsanity_args(this);
		}

		@Override
		public void clear() {
			this.argument = null;

		}

		public Insanity getArgument() {
			return this.argument;
		}

		public testInsanity_args setArgument(Insanity argument) {
			this.argument = argument;
			return this;
		}

		public void unsetArgument() {
			this.argument = null;
		}

		/** Returns true if field argument is set (has been assigned a value) and false otherwise */
		public boolean isSetArgument() {
			return this.argument != null;
		}

		public void setArgumentIsSet(boolean value) {
			if (!value) {
				this.argument = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case ARGUMENT:
				if (value == null) {
					unsetArgument();
				} else {
					setArgument((Insanity)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case ARGUMENT:
				return getArgument();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case ARGUMENT:
				return isSetArgument();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testInsanity_args)
				return this.equals((testInsanity_args)that);
			return false;
		}

		public boolean equals(testInsanity_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.argument, that.argument))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_argument = true && (isSetArgument());
			list.add(present_argument);
			if (present_argument)
				list.add(argument);

			return list.hashCode();
		}

		@Override
		public int compareTo(testInsanity_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetArgument(), other.isSetArgument());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArgument()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.argument, other.argument);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testInsanity_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testInsanity_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testInsanity_args(");
			boolean first = true;

			sb.append("argument:");
			sb.append(this.argument);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (argument != null) {
				argument.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testInsanity_argsStandardScheme extends StandardScheme<testInsanity_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testInsanity_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // ARGUMENT
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.argument = new Insanity();
								struct.argument.read(iprot);
								struct.setArgumentIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testInsanity_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetArgument()) {
					oprot.writeFieldBegin(ARGUMENT_FIELD_DESC);
					struct.argument.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testInsanity_result implements org.apache.thrift.TBase<testInsanity_result, testInsanity_result._Fields>, java.io.Serializable, Cloneable, Comparable<testInsanity_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testInsanity_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.MAP, (short)0);

		public java.util.Map<Long, java.util.Map<Numberz, Insanity>> success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testInsanity_result() {
		}

		public testInsanity_result(
			java.util.Map<Long, java.util.Map<Numberz, Insanity>> success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testInsanity_result(testInsanity_result other) {
			if (other.isSetSuccess()) {
				this.success = new HashMap<Long,java.util.Map<Numberz, Insanity>>(other.success.size());
				for (Map.Entry<Long, java.util.Map<Numberz, Insanity>> elem132 : other.success.entrySet()) {
					long elem134 = elem132.getKey();
					java.util.Map<Numberz, Insanity> elem133 = new HashMap<Numberz,Insanity>(elem132.getValue().size());
					for (Map.Entry<Numberz, Insanity> elem135 : elem132.getValue().entrySet()) {
						Numberz elem137 = elem135.getKey();
						Insanity elem136 = new Insanity(elem135.getValue());
						elem133.put(elem137, elem136);
					}
					this.success.put(elem134, elem133);
				}
			}
		}

		public testInsanity_result deepCopy() {
			return new testInsanity_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public int getSuccessSize() {
			return (this.success == null) ? 0 : this.success.size();
		}

		public void putToSuccess(long key, java.util.Map<Numberz, Insanity> val) {
			if (this.success == null) {
				this.success = new HashMap<Long,java.util.Map<Numberz, Insanity>>();
			}
			this.success.put(key, val);
		}

		public java.util.Map<Long, java.util.Map<Numberz, Insanity>> getSuccess() {
			return this.success;
		}

		public testInsanity_result setSuccess(java.util.Map<Long, java.util.Map<Numberz, Insanity>> success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.util.Map<Long, java.util.Map<Numberz, Insanity>>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testInsanity_result)
				return this.equals((testInsanity_result)that);
			return false;
		}

		public boolean equals(testInsanity_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testInsanity_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testInsanity_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testInsanity_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testInsanity_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testInsanity_resultStandardScheme extends StandardScheme<testInsanity_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testInsanity_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem138 = iprot.readMapBegin();
								struct.success = new HashMap<Long,java.util.Map<Numberz, Insanity>>(2*elem138.size);
								for (int elem139 = 0; elem139 < elem138.size; ++elem139) {
									long elem145 = iprot.readI64();
									org.apache.thrift.protocol.TMap elem141 = iprot.readMapBegin();
									java.util.Map<Numberz, Insanity> elem140 = new HashMap<Numberz,Insanity>(2*elem141.size);
									for (int elem142 = 0; elem142 < elem141.size; ++elem142) {
										Numberz elem144 = Numberz.findByValue(iprot.readI32());
										Insanity elem143 = new Insanity();
										elem143.read(iprot);
										elem140.put(elem144, elem143);
									}
									iprot.readMapEnd();
									struct.success.put(elem145, elem140);
								}
								iprot.readMapEnd();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testInsanity_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I64, org.apache.thrift.protocol.TType.MAP, struct.success.size()));
					for (Map.Entry<Long, java.util.Map<Numberz, Insanity>> elem146 : struct.success.entrySet()) {
						long elem147 = elem146.getKey();
						oprot.writeI64(elem147);
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.STRUCT, elem146.getValue().size()));
						for (Map.Entry<Numberz, Insanity> elem148 : elem146.getValue().entrySet()) {
							Numberz elem149 = elem148.getKey();
							oprot.writeI32(elem149.getValue());
							elem148.getValue().write(oprot);
						}
						oprot.writeMapEnd();
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMulti_args implements org.apache.thrift.TBase<testMulti_args, testMulti_args._Fields>, java.io.Serializable, Cloneable, Comparable<testMulti_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMulti_args");

		private static final org.apache.thrift.protocol.TField ARG0_FIELD_DESC = new org.apache.thrift.protocol.TField("arg0", org.apache.thrift.protocol.TType.BYTE, (short)1);
		private static final org.apache.thrift.protocol.TField ARG1_FIELD_DESC = new org.apache.thrift.protocol.TField("arg1", org.apache.thrift.protocol.TType.I32, (short)2);
		private static final org.apache.thrift.protocol.TField ARG2_FIELD_DESC = new org.apache.thrift.protocol.TField("arg2", org.apache.thrift.protocol.TType.I64, (short)3);
		private static final org.apache.thrift.protocol.TField ARG3_FIELD_DESC = new org.apache.thrift.protocol.TField("arg3", org.apache.thrift.protocol.TType.MAP, (short)4);
		private static final org.apache.thrift.protocol.TField ARG4_FIELD_DESC = new org.apache.thrift.protocol.TField("arg4", org.apache.thrift.protocol.TType.I32, (short)5);
		private static final org.apache.thrift.protocol.TField ARG5_FIELD_DESC = new org.apache.thrift.protocol.TField("arg5", org.apache.thrift.protocol.TType.I64, (short)6);

		public byte arg0;
		public int arg1;
		public long arg2;
		public java.util.Map<Short, String> arg3;
		public Numberz arg4;
		public long arg5;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			ARG0((short)1, "arg0"),
			ARG1((short)2, "arg1"),
			ARG2((short)3, "arg2"),
			ARG3((short)4, "arg3"),
			ARG4((short)5, "arg4"),
			ARG5((short)6, "arg5")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // ARG0
						return ARG0;
					case 2: // ARG1
						return ARG1;
					case 3: // ARG2
						return ARG2;
					case 4: // ARG3
						return ARG3;
					case 5: // ARG4
						return ARG4;
					case 6: // ARG5
						return ARG5;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __ARG0_ISSET_ID = 0;
		private static final int __ARG1_ISSET_ID = 1;
		private static final int __ARG2_ISSET_ID = 2;
		private static final int __ARG5_ISSET_ID = 3;
		private byte __isset_bitfield = 0;
		public testMulti_args() {
		}

		public testMulti_args(
			byte arg0,
			int arg1,
			long arg2,
			java.util.Map<Short, String> arg3,
			Numberz arg4,
			long arg5) {
			this();
			this.arg0 = arg0;
			setArg0IsSet(true);
			this.arg1 = arg1;
			setArg1IsSet(true);
			this.arg2 = arg2;
			setArg2IsSet(true);
			this.arg3 = arg3;
			this.arg4 = arg4;
			this.arg5 = arg5;
			setArg5IsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMulti_args(testMulti_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.arg0 = other.arg0;
			this.arg1 = other.arg1;
			this.arg2 = other.arg2;
			if (other.isSetArg3()) {
				this.arg3 = new HashMap<Short,String>(other.arg3);
			}
			if (other.isSetArg4()) {
				this.arg4 = other.arg4;
			}
			this.arg5 = other.arg5;
		}

		public testMulti_args deepCopy() {
			return new testMulti_args(this);
		}

		@Override
		public void clear() {
			setArg0IsSet(false);
			this.arg0 = (byte)0;

			setArg1IsSet(false);
			this.arg1 = 0;

			setArg2IsSet(false);
			this.arg2 = 0L;

			this.arg3 = null;

			this.arg4 = null;

			setArg5IsSet(false);
			this.arg5 = 0L;

		}

		public byte getArg0() {
			return this.arg0;
		}

		public testMulti_args setArg0(byte arg0) {
			this.arg0 = arg0;
			setArg0IsSet(true);
			return this;
		}

		public void unsetArg0() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ARG0_ISSET_ID);
		}

		/** Returns true if field arg0 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg0() {
			return EncodingUtils.testBit(__isset_bitfield, __ARG0_ISSET_ID);
		}

		public void setArg0IsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ARG0_ISSET_ID, value);
		}

		public int getArg1() {
			return this.arg1;
		}

		public testMulti_args setArg1(int arg1) {
			this.arg1 = arg1;
			setArg1IsSet(true);
			return this;
		}

		public void unsetArg1() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ARG1_ISSET_ID);
		}

		/** Returns true if field arg1 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg1() {
			return EncodingUtils.testBit(__isset_bitfield, __ARG1_ISSET_ID);
		}

		public void setArg1IsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ARG1_ISSET_ID, value);
		}

		public long getArg2() {
			return this.arg2;
		}

		public testMulti_args setArg2(long arg2) {
			this.arg2 = arg2;
			setArg2IsSet(true);
			return this;
		}

		public void unsetArg2() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ARG2_ISSET_ID);
		}

		/** Returns true if field arg2 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg2() {
			return EncodingUtils.testBit(__isset_bitfield, __ARG2_ISSET_ID);
		}

		public void setArg2IsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ARG2_ISSET_ID, value);
		}

		public int getArg3Size() {
			return (this.arg3 == null) ? 0 : this.arg3.size();
		}

		public void putToArg3(short key, String val) {
			if (this.arg3 == null) {
				this.arg3 = new HashMap<Short,String>();
			}
			this.arg3.put(key, val);
		}

		public java.util.Map<Short, String> getArg3() {
			return this.arg3;
		}

		public testMulti_args setArg3(java.util.Map<Short, String> arg3) {
			this.arg3 = arg3;
			return this;
		}

		public void unsetArg3() {
			this.arg3 = null;
		}

		/** Returns true if field arg3 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg3() {
			return this.arg3 != null;
		}

		public void setArg3IsSet(boolean value) {
			if (!value) {
				this.arg3 = null;
			}
		}

		public Numberz getArg4() {
			return this.arg4;
		}

		public testMulti_args setArg4(Numberz arg4) {
			this.arg4 = arg4;
			return this;
		}

		public void unsetArg4() {
			this.arg4 = null;
		}

		/** Returns true if field arg4 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg4() {
			return this.arg4 != null;
		}

		public void setArg4IsSet(boolean value) {
			if (!value) {
				this.arg4 = null;
			}
		}

		public long getArg5() {
			return this.arg5;
		}

		public testMulti_args setArg5(long arg5) {
			this.arg5 = arg5;
			setArg5IsSet(true);
			return this;
		}

		public void unsetArg5() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ARG5_ISSET_ID);
		}

		/** Returns true if field arg5 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg5() {
			return EncodingUtils.testBit(__isset_bitfield, __ARG5_ISSET_ID);
		}

		public void setArg5IsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ARG5_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case ARG0:
				if (value == null) {
					unsetArg0();
				} else {
					setArg0((Byte)value);
				}
				break;

			case ARG1:
				if (value == null) {
					unsetArg1();
				} else {
					setArg1((Integer)value);
				}
				break;

			case ARG2:
				if (value == null) {
					unsetArg2();
				} else {
					setArg2((Long)value);
				}
				break;

			case ARG3:
				if (value == null) {
					unsetArg3();
				} else {
					setArg3((java.util.Map<Short, String>)value);
				}
				break;

			case ARG4:
				if (value == null) {
					unsetArg4();
				} else {
					setArg4((Numberz)value);
				}
				break;

			case ARG5:
				if (value == null) {
					unsetArg5();
				} else {
					setArg5((Long)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case ARG0:
				return getArg0();

			case ARG1:
				return getArg1();

			case ARG2:
				return getArg2();

			case ARG3:
				return getArg3();

			case ARG4:
				return getArg4();

			case ARG5:
				return getArg5();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case ARG0:
				return isSetArg0();
			case ARG1:
				return isSetArg1();
			case ARG2:
				return isSetArg2();
			case ARG3:
				return isSetArg3();
			case ARG4:
				return isSetArg4();
			case ARG5:
				return isSetArg5();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMulti_args)
				return this.equals((testMulti_args)that);
			return false;
		}

		public boolean equals(testMulti_args that) {
			if (that == null)
				return false;
			if (this.arg0 != that.arg0)
				return false;
			if (this.arg1 != that.arg1)
				return false;
			if (this.arg2 != that.arg2)
				return false;
			if (!Objects.equals(this.arg3, that.arg3))
				return false;
			if (!Objects.equals(this.arg4, that.arg4))
				return false;
			if (this.arg5 != that.arg5)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_arg0 = true;
			list.add(present_arg0);
			if (present_arg0)
				list.add(arg0);

			boolean present_arg1 = true;
			list.add(present_arg1);
			if (present_arg1)
				list.add(arg1);

			boolean present_arg2 = true;
			list.add(present_arg2);
			if (present_arg2)
				list.add(arg2);

			boolean present_arg3 = true && (isSetArg3());
			list.add(present_arg3);
			if (present_arg3)
				list.add(arg3);

			boolean present_arg4 = true && (isSetArg4());
			list.add(present_arg4);
			if (present_arg4)
				list.add(arg4.getValue());

			boolean present_arg5 = true;
			list.add(present_arg5);
			if (present_arg5)
				list.add(arg5);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMulti_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetArg0(), other.isSetArg0());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg0()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg0, other.arg0);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg1(), other.isSetArg1());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg1()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg1, other.arg1);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg2(), other.isSetArg2());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg2()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg2, other.arg2);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg3(), other.isSetArg3());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg3()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg3, other.arg3);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg4(), other.isSetArg4());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg4()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg4, other.arg4);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg5(), other.isSetArg5());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg5()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg5, other.arg5);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMulti_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMulti_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMulti_args(");
			boolean first = true;

			sb.append("arg0:");
			sb.append(this.arg0);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg1:");
			sb.append(this.arg1);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg2:");
			sb.append(this.arg2);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg3:");
			sb.append(this.arg3);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg4:");
			sb.append(this.arg4);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg5:");
			sb.append(this.arg5);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMulti_argsStandardScheme extends StandardScheme<testMulti_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMulti_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // ARG0
							if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {
								struct.arg0 = iprot.readByte();
								struct.setArg0IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 2: // ARG1
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.arg1 = iprot.readI32();
								struct.setArg1IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 3: // ARG2
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.arg2 = iprot.readI64();
								struct.setArg2IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 4: // ARG3
							if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
								org.apache.thrift.protocol.TMap elem152 = iprot.readMapBegin();
								struct.arg3 = new HashMap<Short,String>(2*elem152.size);
								for (int elem153 = 0; elem153 < elem152.size; ++elem153) {
									short elem155 = iprot.readI16();
									String elem154 = iprot.readString();
									struct.arg3.put(elem155, elem154);
								}
								iprot.readMapEnd();
								struct.setArg3IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 5: // ARG4
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.arg4 = Numberz.findByValue(iprot.readI32());
								struct.setArg4IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 6: // ARG5
							if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
								struct.arg5 = iprot.readI64();
								struct.setArg5IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMulti_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(ARG0_FIELD_DESC);
				byte elem156 = struct.arg0;
				oprot.writeByte(elem156);
				oprot.writeFieldEnd();
				oprot.writeFieldBegin(ARG1_FIELD_DESC);
				int elem157 = struct.arg1;
				oprot.writeI32(elem157);
				oprot.writeFieldEnd();
				oprot.writeFieldBegin(ARG2_FIELD_DESC);
				long elem158 = struct.arg2;
				oprot.writeI64(elem158);
				oprot.writeFieldEnd();
				if (struct.isSetArg3()) {
					oprot.writeFieldBegin(ARG3_FIELD_DESC);
					oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I16, org.apache.thrift.protocol.TType.STRING, struct.arg3.size()));
					for (Map.Entry<Short, String> elem159 : struct.arg3.entrySet()) {
						short elem160 = elem159.getKey();
						oprot.writeI16(elem160);
						String elem161 = elem159.getValue();
						oprot.writeString(elem161);
					}
					oprot.writeMapEnd();
					oprot.writeFieldEnd();
				}
				if (struct.isSetArg4()) {
					oprot.writeFieldBegin(ARG4_FIELD_DESC);
					Numberz elem162 = struct.arg4;
					oprot.writeI32(elem162.getValue());
					oprot.writeFieldEnd();
				}
				oprot.writeFieldBegin(ARG5_FIELD_DESC);
				long elem163 = struct.arg5;
				oprot.writeI64(elem163);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMulti_result implements org.apache.thrift.TBase<testMulti_result, testMulti_result._Fields>, java.io.Serializable, Cloneable, Comparable<testMulti_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMulti_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);

		public Xtruct success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMulti_result() {
		}

		public testMulti_result(
			Xtruct success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMulti_result(testMulti_result other) {
			if (other.isSetSuccess()) {
				this.success = new Xtruct(other.success);
			}
		}

		public testMulti_result deepCopy() {
			return new testMulti_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public Xtruct getSuccess() {
			return this.success;
		}

		public testMulti_result setSuccess(Xtruct success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Xtruct)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMulti_result)
				return this.equals((testMulti_result)that);
			return false;
		}

		public boolean equals(testMulti_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMulti_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMulti_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMulti_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMulti_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (success != null) {
				success.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMulti_resultStandardScheme extends StandardScheme<testMulti_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMulti_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.success = new Xtruct();
								struct.success.read(iprot);
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMulti_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					struct.success.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testException_args implements org.apache.thrift.TBase<testException_args, testException_args._Fields>, java.io.Serializable, Cloneable, Comparable<testException_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testException_args");

		private static final org.apache.thrift.protocol.TField ARG_FIELD_DESC = new org.apache.thrift.protocol.TField("arg", org.apache.thrift.protocol.TType.STRING, (short)1);

		public String arg;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			ARG((short)1, "arg")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // ARG
						return ARG;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testException_args() {
		}

		public testException_args(
			String arg) {
			this();
			this.arg = arg;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testException_args(testException_args other) {
			if (other.isSetArg()) {
				this.arg = other.arg;
			}
		}

		public testException_args deepCopy() {
			return new testException_args(this);
		}

		@Override
		public void clear() {
			this.arg = null;

		}

		public String getArg() {
			return this.arg;
		}

		public testException_args setArg(String arg) {
			this.arg = arg;
			return this;
		}

		public void unsetArg() {
			this.arg = null;
		}

		/** Returns true if field arg is set (has been assigned a value) and false otherwise */
		public boolean isSetArg() {
			return this.arg != null;
		}

		public void setArgIsSet(boolean value) {
			if (!value) {
				this.arg = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case ARG:
				if (value == null) {
					unsetArg();
				} else {
					setArg((String)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case ARG:
				return getArg();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case ARG:
				return isSetArg();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testException_args)
				return this.equals((testException_args)that);
			return false;
		}

		public boolean equals(testException_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.arg, that.arg))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_arg = true && (isSetArg());
			list.add(present_arg);
			if (present_arg)
				list.add(arg);

			return list.hashCode();
		}

		@Override
		public int compareTo(testException_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetArg(), other.isSetArg());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg, other.arg);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testException_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testException_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testException_args(");
			boolean first = true;

			sb.append("arg:");
			sb.append(this.arg);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testException_argsStandardScheme extends StandardScheme<testException_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testException_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // ARG
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.arg = iprot.readString();
								struct.setArgIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testException_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetArg()) {
					oprot.writeFieldBegin(ARG_FIELD_DESC);
					String elem164 = struct.arg;
					oprot.writeString(elem164);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testException_result implements org.apache.thrift.TBase<testException_result, testException_result._Fields>, java.io.Serializable, Cloneable, Comparable<testException_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testException_result");

		private static final org.apache.thrift.protocol.TField ERR1_FIELD_DESC = new org.apache.thrift.protocol.TField("err1", org.apache.thrift.protocol.TType.STRUCT, (short)1);

		public Xception err1;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			ERR1((short)1, "err1")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // ERR1
						return ERR1;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testException_result() {
		}

		public testException_result(
			Xception err1) {
			this();
			this.err1 = err1;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testException_result(testException_result other) {
			if (other.isSetErr1()) {
				this.err1 = new Xception(other.err1);
			}
		}

		public testException_result deepCopy() {
			return new testException_result(this);
		}

		@Override
		public void clear() {
			this.err1 = null;

		}

		public Xception getErr1() {
			return this.err1;
		}

		public testException_result setErr1(Xception err1) {
			this.err1 = err1;
			return this;
		}

		public void unsetErr1() {
			this.err1 = null;
		}

		/** Returns true if field err1 is set (has been assigned a value) and false otherwise */
		public boolean isSetErr1() {
			return this.err1 != null;
		}

		public void setErr1IsSet(boolean value) {
			if (!value) {
				this.err1 = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case ERR1:
				if (value == null) {
					unsetErr1();
				} else {
					setErr1((Xception)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case ERR1:
				return getErr1();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case ERR1:
				return isSetErr1();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testException_result)
				return this.equals((testException_result)that);
			return false;
		}

		public boolean equals(testException_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.err1, that.err1))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_err1 = true && (isSetErr1());
			list.add(present_err1);
			if (present_err1)
				list.add(err1);

			return list.hashCode();
		}

		@Override
		public int compareTo(testException_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetErr1(), other.isSetErr1());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetErr1()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.err1, other.err1);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testException_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testException_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testException_result(");
			boolean first = true;

			sb.append("err1:");
			sb.append(this.err1);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (err1 != null) {
				err1.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testException_resultStandardScheme extends StandardScheme<testException_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testException_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // ERR1
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.err1 = new Xception();
								struct.err1.read(iprot);
								struct.setErr1IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testException_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetErr1()) {
					oprot.writeFieldBegin(ERR1_FIELD_DESC);
					struct.err1.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMultiException_args implements org.apache.thrift.TBase<testMultiException_args, testMultiException_args._Fields>, java.io.Serializable, Cloneable, Comparable<testMultiException_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMultiException_args");

		private static final org.apache.thrift.protocol.TField ARG0_FIELD_DESC = new org.apache.thrift.protocol.TField("arg0", org.apache.thrift.protocol.TType.STRING, (short)1);
		private static final org.apache.thrift.protocol.TField ARG1_FIELD_DESC = new org.apache.thrift.protocol.TField("arg1", org.apache.thrift.protocol.TType.STRING, (short)2);

		public String arg0;
		public String arg1;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			ARG0((short)1, "arg0"),
			ARG1((short)2, "arg1")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // ARG0
						return ARG0;
					case 2: // ARG1
						return ARG1;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMultiException_args() {
		}

		public testMultiException_args(
			String arg0,
			String arg1) {
			this();
			this.arg0 = arg0;
			this.arg1 = arg1;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMultiException_args(testMultiException_args other) {
			if (other.isSetArg0()) {
				this.arg0 = other.arg0;
			}
			if (other.isSetArg1()) {
				this.arg1 = other.arg1;
			}
		}

		public testMultiException_args deepCopy() {
			return new testMultiException_args(this);
		}

		@Override
		public void clear() {
			this.arg0 = null;

			this.arg1 = null;

		}

		public String getArg0() {
			return this.arg0;
		}

		public testMultiException_args setArg0(String arg0) {
			this.arg0 = arg0;
			return this;
		}

		public void unsetArg0() {
			this.arg0 = null;
		}

		/** Returns true if field arg0 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg0() {
			return this.arg0 != null;
		}

		public void setArg0IsSet(boolean value) {
			if (!value) {
				this.arg0 = null;
			}
		}

		public String getArg1() {
			return this.arg1;
		}

		public testMultiException_args setArg1(String arg1) {
			this.arg1 = arg1;
			return this;
		}

		public void unsetArg1() {
			this.arg1 = null;
		}

		/** Returns true if field arg1 is set (has been assigned a value) and false otherwise */
		public boolean isSetArg1() {
			return this.arg1 != null;
		}

		public void setArg1IsSet(boolean value) {
			if (!value) {
				this.arg1 = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case ARG0:
				if (value == null) {
					unsetArg0();
				} else {
					setArg0((String)value);
				}
				break;

			case ARG1:
				if (value == null) {
					unsetArg1();
				} else {
					setArg1((String)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case ARG0:
				return getArg0();

			case ARG1:
				return getArg1();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case ARG0:
				return isSetArg0();
			case ARG1:
				return isSetArg1();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMultiException_args)
				return this.equals((testMultiException_args)that);
			return false;
		}

		public boolean equals(testMultiException_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.arg0, that.arg0))
				return false;
			if (!Objects.equals(this.arg1, that.arg1))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_arg0 = true && (isSetArg0());
			list.add(present_arg0);
			if (present_arg0)
				list.add(arg0);

			boolean present_arg1 = true && (isSetArg1());
			list.add(present_arg1);
			if (present_arg1)
				list.add(arg1);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMultiException_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetArg0(), other.isSetArg0());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg0()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg0, other.arg0);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetArg1(), other.isSetArg1());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetArg1()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.arg1, other.arg1);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMultiException_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMultiException_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMultiException_args(");
			boolean first = true;

			sb.append("arg0:");
			sb.append(this.arg0);
			first = false;
			if (!first) sb.append(", ");
			sb.append("arg1:");
			sb.append(this.arg1);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMultiException_argsStandardScheme extends StandardScheme<testMultiException_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMultiException_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // ARG0
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.arg0 = iprot.readString();
								struct.setArg0IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 2: // ARG1
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.arg1 = iprot.readString();
								struct.setArg1IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMultiException_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetArg0()) {
					oprot.writeFieldBegin(ARG0_FIELD_DESC);
					String elem165 = struct.arg0;
					oprot.writeString(elem165);
					oprot.writeFieldEnd();
				}
				if (struct.isSetArg1()) {
					oprot.writeFieldBegin(ARG1_FIELD_DESC);
					String elem166 = struct.arg1;
					oprot.writeString(elem166);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testMultiException_result implements org.apache.thrift.TBase<testMultiException_result, testMultiException_result._Fields>, java.io.Serializable, Cloneable, Comparable<testMultiException_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testMultiException_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
		private static final org.apache.thrift.protocol.TField ERR1_FIELD_DESC = new org.apache.thrift.protocol.TField("err1", org.apache.thrift.protocol.TType.STRUCT, (short)1);
		private static final org.apache.thrift.protocol.TField ERR2_FIELD_DESC = new org.apache.thrift.protocol.TField("err2", org.apache.thrift.protocol.TType.STRUCT, (short)2);

		public Xtruct success;
		public Xception err1;
		public Xception2 err2;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success"),
			ERR1((short)1, "err1"),
			ERR2((short)2, "err2")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					case 1: // ERR1
						return ERR1;
					case 2: // ERR2
						return ERR2;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testMultiException_result() {
		}

		public testMultiException_result(
			Xtruct success,
			Xception err1,
			Xception2 err2) {
			this();
			this.success = success;
			this.err1 = err1;
			this.err2 = err2;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testMultiException_result(testMultiException_result other) {
			if (other.isSetSuccess()) {
				this.success = new Xtruct(other.success);
			}
			if (other.isSetErr1()) {
				this.err1 = new Xception(other.err1);
			}
			if (other.isSetErr2()) {
				this.err2 = new Xception2(other.err2);
			}
		}

		public testMultiException_result deepCopy() {
			return new testMultiException_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

			this.err1 = null;

			this.err2 = null;

		}

		public Xtruct getSuccess() {
			return this.success;
		}

		public testMultiException_result setSuccess(Xtruct success) {
			this.success = success;
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public Xception getErr1() {
			return this.err1;
		}

		public testMultiException_result setErr1(Xception err1) {
			this.err1 = err1;
			return this;
		}

		public void unsetErr1() {
			this.err1 = null;
		}

		/** Returns true if field err1 is set (has been assigned a value) and false otherwise */
		public boolean isSetErr1() {
			return this.err1 != null;
		}

		public void setErr1IsSet(boolean value) {
			if (!value) {
				this.err1 = null;
			}
		}

		public Xception2 getErr2() {
			return this.err2;
		}

		public testMultiException_result setErr2(Xception2 err2) {
			this.err2 = err2;
			return this;
		}

		public void unsetErr2() {
			this.err2 = null;
		}

		/** Returns true if field err2 is set (has been assigned a value) and false otherwise */
		public boolean isSetErr2() {
			return this.err2 != null;
		}

		public void setErr2IsSet(boolean value) {
			if (!value) {
				this.err2 = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Xtruct)value);
				}
				break;

			case ERR1:
				if (value == null) {
					unsetErr1();
				} else {
					setErr1((Xception)value);
				}
				break;

			case ERR2:
				if (value == null) {
					unsetErr2();
				} else {
					setErr2((Xception2)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			case ERR1:
				return getErr1();

			case ERR2:
				return getErr2();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			case ERR1:
				return isSetErr1();
			case ERR2:
				return isSetErr2();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testMultiException_result)
				return this.equals((testMultiException_result)that);
			return false;
		}

		public boolean equals(testMultiException_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			if (!Objects.equals(this.err1, that.err1))
				return false;
			if (!Objects.equals(this.err2, that.err2))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			boolean present_err1 = true && (isSetErr1());
			list.add(present_err1);
			if (present_err1)
				list.add(err1);

			boolean present_err2 = true && (isSetErr2());
			list.add(present_err2);
			if (present_err2)
				list.add(err2);

			return list.hashCode();
		}

		@Override
		public int compareTo(testMultiException_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetErr1(), other.isSetErr1());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetErr1()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.err1, other.err1);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			lastComparison = Boolean.compare(isSetErr2(), other.isSetErr2());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetErr2()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.err2, other.err2);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMultiException_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testMultiException_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testMultiException_result(");
			boolean first = true;

			sb.append("success:");
			sb.append(this.success);
			first = false;
			if (!first) sb.append(", ");
			sb.append("err1:");
			sb.append(this.err1);
			first = false;
			if (!first) sb.append(", ");
			sb.append("err2:");
			sb.append(this.err2);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
			if (success != null) {
				success.validate();
			}
			if (err1 != null) {
				err1.validate();
			}
			if (err2 != null) {
				err2.validate();
			}
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testMultiException_resultStandardScheme extends StandardScheme<testMultiException_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testMultiException_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.success = new Xtruct();
								struct.success.read(iprot);
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 1: // ERR1
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.err1 = new Xception();
								struct.err1.read(iprot);
								struct.setErr1IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						case 2: // ERR2
							if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
								struct.err2 = new Xception2();
								struct.err2.read(iprot);
								struct.setErr2IsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testMultiException_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					struct.success.write(oprot);
					oprot.writeFieldEnd();
				}
				if (struct.isSetErr1()) {
					oprot.writeFieldBegin(ERR1_FIELD_DESC);
					struct.err1.write(oprot);
					oprot.writeFieldEnd();
				}
				if (struct.isSetErr2()) {
					oprot.writeFieldBegin(ERR2_FIELD_DESC);
					struct.err2.write(oprot);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testUncaughtException_args implements org.apache.thrift.TBase<testUncaughtException_args, testUncaughtException_args._Fields>, java.io.Serializable, Cloneable, Comparable<testUncaughtException_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testUncaughtException_args");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testUncaughtException_args() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testUncaughtException_args(testUncaughtException_args other) {
		}

		public testUncaughtException_args deepCopy() {
			return new testUncaughtException_args(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testUncaughtException_args)
				return this.equals((testUncaughtException_args)that);
			return false;
		}

		public boolean equals(testUncaughtException_args that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testUncaughtException_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncaughtException_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncaughtException_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testUncaughtException_args(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testUncaughtException_argsStandardScheme extends StandardScheme<testUncaughtException_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testUncaughtException_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testUncaughtException_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testUncaughtException_result implements org.apache.thrift.TBase<testUncaughtException_result, testUncaughtException_result._Fields>, java.io.Serializable, Cloneable, Comparable<testUncaughtException_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testUncaughtException_result");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testUncaughtException_result() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testUncaughtException_result(testUncaughtException_result other) {
		}

		public testUncaughtException_result deepCopy() {
			return new testUncaughtException_result(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testUncaughtException_result)
				return this.equals((testUncaughtException_result)that);
			return false;
		}

		public boolean equals(testUncaughtException_result that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testUncaughtException_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncaughtException_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncaughtException_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testUncaughtException_result(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testUncaughtException_resultStandardScheme extends StandardScheme<testUncaughtException_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testUncaughtException_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testUncaughtException_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testUncheckedTApplicationException_args implements org.apache.thrift.TBase<testUncheckedTApplicationException_args, testUncheckedTApplicationException_args._Fields>, java.io.Serializable, Cloneable, Comparable<testUncheckedTApplicationException_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testUncheckedTApplicationException_args");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testUncheckedTApplicationException_args() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testUncheckedTApplicationException_args(testUncheckedTApplicationException_args other) {
		}

		public testUncheckedTApplicationException_args deepCopy() {
			return new testUncheckedTApplicationException_args(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testUncheckedTApplicationException_args)
				return this.equals((testUncheckedTApplicationException_args)that);
			return false;
		}

		public boolean equals(testUncheckedTApplicationException_args that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testUncheckedTApplicationException_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncheckedTApplicationException_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncheckedTApplicationException_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testUncheckedTApplicationException_args(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testUncheckedTApplicationException_argsStandardScheme extends StandardScheme<testUncheckedTApplicationException_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testUncheckedTApplicationException_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testUncheckedTApplicationException_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testUncheckedTApplicationException_result implements org.apache.thrift.TBase<testUncheckedTApplicationException_result, testUncheckedTApplicationException_result._Fields>, java.io.Serializable, Cloneable, Comparable<testUncheckedTApplicationException_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testUncheckedTApplicationException_result");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testUncheckedTApplicationException_result() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testUncheckedTApplicationException_result(testUncheckedTApplicationException_result other) {
		}

		public testUncheckedTApplicationException_result deepCopy() {
			return new testUncheckedTApplicationException_result(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testUncheckedTApplicationException_result)
				return this.equals((testUncheckedTApplicationException_result)that);
			return false;
		}

		public boolean equals(testUncheckedTApplicationException_result that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testUncheckedTApplicationException_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncheckedTApplicationException_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testUncheckedTApplicationException_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testUncheckedTApplicationException_result(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testUncheckedTApplicationException_resultStandardScheme extends StandardScheme<testUncheckedTApplicationException_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testUncheckedTApplicationException_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testUncheckedTApplicationException_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testRequestTooLarge_args implements org.apache.thrift.TBase<testRequestTooLarge_args, testRequestTooLarge_args._Fields>, java.io.Serializable, Cloneable, Comparable<testRequestTooLarge_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testRequestTooLarge_args");

		private static final org.apache.thrift.protocol.TField REQUEST_FIELD_DESC = new org.apache.thrift.protocol.TField("request", org.apache.thrift.protocol.TType.STRING, (short)1);

		public java.nio.ByteBuffer request;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			REQUEST((short)1, "request")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // REQUEST
						return REQUEST;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testRequestTooLarge_args() {
		}

		public testRequestTooLarge_args(
			java.nio.ByteBuffer request) {
			this();
			this.request = org.apache.thrift.TBaseHelper.copyBinary(request);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testRequestTooLarge_args(testRequestTooLarge_args other) {
			if (other.isSetRequest()) {
				this.request = org.apache.thrift.TBaseHelper.copyBinary(other.request);
			}
		}

		public testRequestTooLarge_args deepCopy() {
			return new testRequestTooLarge_args(this);
		}

		@Override
		public void clear() {
			this.request = null;

		}

		public byte[] getRequest() {
			setRequest(org.apache.thrift.TBaseHelper.rightSize(request));
			return request == null ? null : request.array();
		}

		public java.nio.ByteBuffer bufferForRequest() {
			return org.apache.thrift.TBaseHelper.copyBinary(request);
		}

		public testRequestTooLarge_args setRequest(byte[] request) {
			this.request = request == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(Arrays.copyOf(request, request.length));
			return this;
		}

		public testRequestTooLarge_args setRequest(java.nio.ByteBuffer request) {
			this.request = org.apache.thrift.TBaseHelper.copyBinary(request);
			return this;
		}

		public void unsetRequest() {
			this.request = null;
		}

		/** Returns true if field request is set (has been assigned a value) and false otherwise */
		public boolean isSetRequest() {
			return this.request != null;
		}

		public void setRequestIsSet(boolean value) {
			if (!value) {
				this.request = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case REQUEST:
				if (value == null) {
					unsetRequest();
				} else {
					setRequest((java.nio.ByteBuffer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case REQUEST:
				return getRequest();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case REQUEST:
				return isSetRequest();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testRequestTooLarge_args)
				return this.equals((testRequestTooLarge_args)that);
			return false;
		}

		public boolean equals(testRequestTooLarge_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.request, that.request))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_request = true && (isSetRequest());
			list.add(present_request);
			if (present_request)
				list.add(request);

			return list.hashCode();
		}

		@Override
		public int compareTo(testRequestTooLarge_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetRequest(), other.isSetRequest());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetRequest()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.request, other.request);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testRequestTooLarge_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testRequestTooLarge_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testRequestTooLarge_args(");
			boolean first = true;

			sb.append("request:");
			if (this.request == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.request, sb);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testRequestTooLarge_argsStandardScheme extends StandardScheme<testRequestTooLarge_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testRequestTooLarge_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // REQUEST
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.request = iprot.readBinary();
								struct.setRequestIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testRequestTooLarge_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetRequest()) {
					oprot.writeFieldBegin(REQUEST_FIELD_DESC);
					java.nio.ByteBuffer elem167 = struct.request;
					oprot.writeBinary(elem167);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testRequestTooLarge_result implements org.apache.thrift.TBase<testRequestTooLarge_result, testRequestTooLarge_result._Fields>, java.io.Serializable, Cloneable, Comparable<testRequestTooLarge_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testRequestTooLarge_result");


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testRequestTooLarge_result() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testRequestTooLarge_result(testRequestTooLarge_result other) {
		}

		public testRequestTooLarge_result deepCopy() {
			return new testRequestTooLarge_result(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testRequestTooLarge_result)
				return this.equals((testRequestTooLarge_result)that);
			return false;
		}

		public boolean equals(testRequestTooLarge_result that) {
			if (that == null)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(testRequestTooLarge_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testRequestTooLarge_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testRequestTooLarge_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testRequestTooLarge_result(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testRequestTooLarge_resultStandardScheme extends StandardScheme<testRequestTooLarge_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testRequestTooLarge_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testRequestTooLarge_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testResponseTooLarge_args implements org.apache.thrift.TBase<testResponseTooLarge_args, testResponseTooLarge_args._Fields>, java.io.Serializable, Cloneable, Comparable<testResponseTooLarge_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testResponseTooLarge_args");

		private static final org.apache.thrift.protocol.TField REQUEST_FIELD_DESC = new org.apache.thrift.protocol.TField("request", org.apache.thrift.protocol.TType.STRING, (short)1);

		public java.nio.ByteBuffer request;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			REQUEST((short)1, "request")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // REQUEST
						return REQUEST;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testResponseTooLarge_args() {
		}

		public testResponseTooLarge_args(
			java.nio.ByteBuffer request) {
			this();
			this.request = org.apache.thrift.TBaseHelper.copyBinary(request);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testResponseTooLarge_args(testResponseTooLarge_args other) {
			if (other.isSetRequest()) {
				this.request = org.apache.thrift.TBaseHelper.copyBinary(other.request);
			}
		}

		public testResponseTooLarge_args deepCopy() {
			return new testResponseTooLarge_args(this);
		}

		@Override
		public void clear() {
			this.request = null;

		}

		public byte[] getRequest() {
			setRequest(org.apache.thrift.TBaseHelper.rightSize(request));
			return request == null ? null : request.array();
		}

		public java.nio.ByteBuffer bufferForRequest() {
			return org.apache.thrift.TBaseHelper.copyBinary(request);
		}

		public testResponseTooLarge_args setRequest(byte[] request) {
			this.request = request == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(Arrays.copyOf(request, request.length));
			return this;
		}

		public testResponseTooLarge_args setRequest(java.nio.ByteBuffer request) {
			this.request = org.apache.thrift.TBaseHelper.copyBinary(request);
			return this;
		}

		public void unsetRequest() {
			this.request = null;
		}

		/** Returns true if field request is set (has been assigned a value) and false otherwise */
		public boolean isSetRequest() {
			return this.request != null;
		}

		public void setRequestIsSet(boolean value) {
			if (!value) {
				this.request = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case REQUEST:
				if (value == null) {
					unsetRequest();
				} else {
					setRequest((java.nio.ByteBuffer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case REQUEST:
				return getRequest();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case REQUEST:
				return isSetRequest();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testResponseTooLarge_args)
				return this.equals((testResponseTooLarge_args)that);
			return false;
		}

		public boolean equals(testResponseTooLarge_args that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.request, that.request))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_request = true && (isSetRequest());
			list.add(present_request);
			if (present_request)
				list.add(request);

			return list.hashCode();
		}

		@Override
		public int compareTo(testResponseTooLarge_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetRequest(), other.isSetRequest());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetRequest()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.request, other.request);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testResponseTooLarge_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testResponseTooLarge_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testResponseTooLarge_args(");
			boolean first = true;

			sb.append("request:");
			if (this.request == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.request, sb);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testResponseTooLarge_argsStandardScheme extends StandardScheme<testResponseTooLarge_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testResponseTooLarge_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // REQUEST
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.request = iprot.readBinary();
								struct.setRequestIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testResponseTooLarge_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetRequest()) {
					oprot.writeFieldBegin(REQUEST_FIELD_DESC);
					java.nio.ByteBuffer elem168 = struct.request;
					oprot.writeBinary(elem168);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testResponseTooLarge_result implements org.apache.thrift.TBase<testResponseTooLarge_result, testResponseTooLarge_result._Fields>, java.io.Serializable, Cloneable, Comparable<testResponseTooLarge_result> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testResponseTooLarge_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);

		public java.nio.ByteBuffer success;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 0: // SUCCESS
						return SUCCESS;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public testResponseTooLarge_result() {
		}

		public testResponseTooLarge_result(
			java.nio.ByteBuffer success) {
			this();
			this.success = org.apache.thrift.TBaseHelper.copyBinary(success);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testResponseTooLarge_result(testResponseTooLarge_result other) {
			if (other.isSetSuccess()) {
				this.success = org.apache.thrift.TBaseHelper.copyBinary(other.success);
			}
		}

		public testResponseTooLarge_result deepCopy() {
			return new testResponseTooLarge_result(this);
		}

		@Override
		public void clear() {
			this.success = null;

		}

		public byte[] getSuccess() {
			setSuccess(org.apache.thrift.TBaseHelper.rightSize(success));
			return success == null ? null : success.array();
		}

		public java.nio.ByteBuffer bufferForSuccess() {
			return org.apache.thrift.TBaseHelper.copyBinary(success);
		}

		public testResponseTooLarge_result setSuccess(byte[] success) {
			this.success = success == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(Arrays.copyOf(success, success.length));
			return this;
		}

		public testResponseTooLarge_result setSuccess(java.nio.ByteBuffer success) {
			this.success = org.apache.thrift.TBaseHelper.copyBinary(success);
			return this;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((java.nio.ByteBuffer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return getSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testResponseTooLarge_result)
				return this.equals((testResponseTooLarge_result)that);
			return false;
		}

		public boolean equals(testResponseTooLarge_result that) {
			if (that == null)
				return false;
			if (!Objects.equals(this.success, that.success))
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true && (isSetSuccess());
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(testResponseTooLarge_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testResponseTooLarge_resultStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testResponseTooLarge_resultStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testResponseTooLarge_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.success, sb);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testResponseTooLarge_resultStandardScheme extends StandardScheme<testResponseTooLarge_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testResponseTooLarge_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 0: // SUCCESS
							if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
								struct.success = iprot.readBinary();
								struct.setSuccessIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testResponseTooLarge_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					java.nio.ByteBuffer elem169 = struct.success;
					oprot.writeBinary(elem169);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

	public static class testOneway_args implements org.apache.thrift.TBase<testOneway_args, testOneway_args._Fields>, java.io.Serializable, Cloneable, Comparable<testOneway_args> {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("testOneway_args");

		private static final org.apache.thrift.protocol.TField MILLISECONDS_TO_SLEEP_FIELD_DESC = new org.apache.thrift.protocol.TField("millisecondsToSleep", org.apache.thrift.protocol.TType.I32, (short)1);

		public int millisecondsToSleep;
		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			MILLISECONDS_TO_SLEEP((short)1, "millisecondsToSleep")
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
					case 1: // MILLISECONDS_TO_SLEEP
						return MILLISECONDS_TO_SLEEP;
					default:
						return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __MILLISECONDSTOSLEEP_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public testOneway_args() {
		}

		public testOneway_args(
			int millisecondsToSleep) {
			this();
			this.millisecondsToSleep = millisecondsToSleep;
			setMillisecondsToSleepIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public testOneway_args(testOneway_args other) {
			__isset_bitfield = other.__isset_bitfield;
			this.millisecondsToSleep = other.millisecondsToSleep;
		}

		public testOneway_args deepCopy() {
			return new testOneway_args(this);
		}

		@Override
		public void clear() {
			setMillisecondsToSleepIsSet(false);
			this.millisecondsToSleep = 0;

		}

		public int getMillisecondsToSleep() {
			return this.millisecondsToSleep;
		}

		public testOneway_args setMillisecondsToSleep(int millisecondsToSleep) {
			this.millisecondsToSleep = millisecondsToSleep;
			setMillisecondsToSleepIsSet(true);
			return this;
		}

		public void unsetMillisecondsToSleep() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MILLISECONDSTOSLEEP_ISSET_ID);
		}

		/** Returns true if field millisecondsToSleep is set (has been assigned a value) and false otherwise */
		public boolean isSetMillisecondsToSleep() {
			return EncodingUtils.testBit(__isset_bitfield, __MILLISECONDSTOSLEEP_ISSET_ID);
		}

		public void setMillisecondsToSleepIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MILLISECONDSTOSLEEP_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case MILLISECONDS_TO_SLEEP:
				if (value == null) {
					unsetMillisecondsToSleep();
				} else {
					setMillisecondsToSleep((Integer)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case MILLISECONDS_TO_SLEEP:
				return getMillisecondsToSleep();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case MILLISECONDS_TO_SLEEP:
				return isSetMillisecondsToSleep();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof testOneway_args)
				return this.equals((testOneway_args)that);
			return false;
		}

		public boolean equals(testOneway_args that) {
			if (that == null)
				return false;
			if (this.millisecondsToSleep != that.millisecondsToSleep)
				return false;
			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_millisecondsToSleep = true;
			list.add(present_millisecondsToSleep);
			if (present_millisecondsToSleep)
				list.add(millisecondsToSleep);

			return list.hashCode();
		}

		@Override
		public int compareTo(testOneway_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.compare(isSetMillisecondsToSleep(), other.isSetMillisecondsToSleep());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetMillisecondsToSleep()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.millisecondsToSleep, other.millisecondsToSleep);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			if (iprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testOneway_argsStandardScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			if (oprot.getScheme() != StandardScheme.class) {
				throw new UnsupportedOperationException();
			}
			new testOneway_argsStandardScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("testOneway_args(");
			boolean first = true;

			sb.append("millisecondsToSleep:");
			sb.append(this.millisecondsToSleep);
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class testOneway_argsStandardScheme extends StandardScheme<testOneway_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, testOneway_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true) {
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
						break;
					}
					switch (schemeField.id) {
						case 1: // MILLISECONDS_TO_SLEEP
							if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
								struct.millisecondsToSleep = iprot.readI32();
								struct.setMillisecondsToSleepIsSet(true);
							} else {
								org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
							}
							break;
						default:
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, testOneway_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldBegin(MILLISECONDS_TO_SLEEP_FIELD_DESC);
				int elem170 = struct.millisecondsToSleep;
				oprot.writeI32(elem170);
				oprot.writeFieldEnd();
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

	}

}