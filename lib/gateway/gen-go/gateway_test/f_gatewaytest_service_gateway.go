// Autogenerated by Frugal Compiler (2.14.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package gateway_test

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/Sirupsen/logrus"
	"github.com/Workiva/frugal/lib/gateway"
	"github.com/Workiva/frugal/lib/go"
	"github.com/fatih/structs"
	"github.com/gorilla/mux"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal
var _ = logrus.DebugLevel

// GatewayTestContext forwards HTTP requests to a Frugal service
type GatewayTestContext struct {
	Client     *FGatewayTestClient
	Marshalers gateway.MarshalerRegistry
}

// GatewayTestHandler is a wrapper to provide context to HTTP handlers
type GatewayTestHandler struct {
	*GatewayTestContext

	// ContextHandlerFunc is the interface which our Handlers will implement
	ContextHandlerFunc func(*GatewayTestContext, http.ResponseWriter, *http.Request) (int, error)
}

// ServeHTTP handles HTTP requests with an included context
func (handler GatewayTestHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	status, err := handler.ContextHandlerFunc(handler.GatewayTestContext, w, r)
	if err != nil {
		log.Printf("HTTP %d: %q", status, err)
		switch status {
		// TODO:
		// customize error handling using context
		}
	}

}

// GatewayTestGetContainerHandler forwards HTTP requests to a Frugal service
func GatewayTestGetContainerHandler(context *GatewayTestContext, responseWriter http.ResponseWriter, request *http.Request) (int, error) {
	flusher, _ := responseWriter.(http.Flusher)

	inMarshaler, outMarshaler := context.Marshalers.MarshalerForRequest(request)

	// Assemble a Frugal payload of the correct type
	payload := &BaseType{}

	// Decode the request using the registered inbound marshaler
	decoder := inMarshaler.NewDecoder(request.Body)
	defer request.Body.Close()
	err := decoder.Decode(payload)
	if err != nil && err != io.EOF {
		panic(err) // TODO: Customize error handling
	}

	// Map any path or query parameters into the payload
	vars := mux.Vars(request)
	queries := request.URL.Query()
	for _, field := range structs.Fields(payload) {
		for k, v := range vars {
			if strings.Contains(field.Tag("json"), k) {
				field.Set(v)
			}
		}

		for k, v := range queries {
			if k == field.Tag("json") {
				field.Set(v[0]) // Take the first query parameter
			}
		}
	}

	// Call the Frugal client with the assembled payload
	response, err := context.Client.GetContainer(frugal.NewFContext(""), payload)
	if err != nil {
		panic(err) // TODO: Customize error handling
	}

	// Serialize the Frugal response into a JSON response
	buf, err := outMarshaler.Marshal(response)
	if err != nil {
		panic(err) // TODO: Customize error handling
	}
	responseWriter.WriteHeader(http.StatusOK)
	responseWriter.Write(buf)
	flusher.Flush()

	return http.StatusOK, nil
}
