// Autogenerated by Frugal Compiler (0.0.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package event

import (
	"fmt"
	"log"

	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/Workiva/frugal/lib/go"
)

const (
	topicBase = "event"
	delimiter = "."
)

type EventsPubSub interface {
	EventCreated(*Event) error
}

type EventsPublisher struct {
	ClientProvider map[string]*frugal.Client
	SeqId          int32
}

func NewEventsPublisher(t frugal.TransportFactory, f thrift.TTransportFactory, p thrift.TProtocolFactory) *EventsPublisher {
	return &EventsPublisher{
		ClientProvider: newEventsClientProvider(t, f, p),
		SeqId:          0,
	}
}

func (l *EventsPublisher) EventCreated(req *Event) error {
	op := "EventCreated"
	topic := getEventsPubSubTopic(op)
	client, ok := l.ClientProvider[topic]
	if !ok {
		return thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+op)
	}
	oprot := client.Protocol
	l.SeqId++
	if err := oprot.WriteMessageBegin(op, thrift.CALL, l.SeqId); err != nil {
		return err
	}
	if err := req.Write(oprot); err != nil {
		return err
	}
	if err := oprot.WriteMessageEnd(); err != nil {
		return err
	}
	return oprot.Flush()
}

func newEventsClientProvider(t frugal.TransportFactory, f thrift.TTransportFactory, p thrift.TProtocolFactory) map[string]*frugal.Client {
	provider := make(map[string]*frugal.Client)

	var (
		topic     string
		transport frugal.Transport
	)
	topic = getEventsPubSubTopic("EventCreated")
	transport = t.GetTransport(topic)
	if f != nil {
		transport.ApplyProxy(f)
	}
	provider[topic] = &frugal.Client{
		Protocol:  p.GetProtocol(transport.ThriftTransport()),
		Transport: transport,
	}

	return provider
}

func getEventsPubSubTopic(op string) string {
	return fmt.Sprintf("%s%s%s", topicBase, delimiter, op)
}

type EventsSubscriber struct {
	Handler        EventsPubSub
	ClientProvider map[string]*frugal.Client
}

func NewEventsSubscriber(handler EventsPubSub, t frugal.TransportFactory, f thrift.TTransportFactory, p thrift.TProtocolFactory) *EventsSubscriber {
	return &EventsSubscriber{
		Handler:        handler,
		ClientProvider: newEventsClientProvider(t, f, p),
	}
}

func (l *EventsSubscriber) SubscribeEventCreated() error {
	op := "EventCreated"
	topic := getEventsPubSubTopic(op)
	client, ok := l.ClientProvider[topic]
	if !ok {
		return thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+op)
	}

	if err := client.Transport.Subscribe(); err != nil {
		return err
	}

	go func() {
		for {
			received, err := l.recvEventCreated(op, client.Protocol)
			if err != nil {
				if e, ok := err.(thrift.TTransportException); ok && e.TypeId() == thrift.END_OF_FILE {
					break
				}
				log.Println("frugal: error receiving:", err)
			}
			l.Handler.EventCreated(received)
		}
	}()

	return nil
}

func (l *EventsSubscriber) recvEventCreated(op string, iprot thrift.TProtocol) (*Event, error) {
	name, _, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return nil, err
	}
	if name != op {
		iprot.Skip(thrift.STRUCT)
		iprot.ReadMessageEnd()
		x9 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
		return nil, x9
	}
	req := &Event{}
	if err := req.Read(iprot); err != nil {
		return nil, err
	}

	iprot.ReadMessageEnd()
	return req, nil
}

func (l *EventsSubscriber) UnsubscribeEventCreated() error {
	op := "EventCreated"
	topic := getEventsPubSubTopic(op)
	client, ok := l.ClientProvider[topic]
	if !ok {
		return thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+op)
	}

	return client.Transport.Unsubscribe()
}
