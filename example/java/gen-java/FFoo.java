/**
 * Autogenerated by Frugal Compiler (0.0.1)
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */



import com.workiva.frugal.FContext;
import com.workiva.frugal.processor.FProcessor;
import com.workiva.frugal.processor.FProcessorFunction;
import com.workiva.frugal.protocol.FProtocol;
import com.workiva.frugal.protocol.FProtocolFactory;
import com.workiva.frugal.registry.FAsyncCallback;
import com.workiva.frugal.registry.FClientRegistry;
import com.workiva.frugal.transport.FTransport;
import org.apache.thrift.TApplicationException;
import org.apache.thrift.TException;
import org.apache.thrift.protocol.TMessage;
import org.apache.thrift.protocol.TMessageType;
import org.apache.thrift.protocol.TProtocolUtil;
import org.apache.thrift.protocol.TType;
import org.apache.thrift.transport.TTransport;

import javax.annotation.Generated;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ArrayBlockingQueue;


@Generated(value = "Autogenerated by Frugal Compiler (0.0.1)", date = "2016-1-12")
public class FFoo {

	/**
	 * This is a thrift service. Frugal will generate bindings that include 
	 * a frugal Context for each service call.
	 */
	public interface Iface {

		/**
		 * Ping the server.
		 */
		public void ping(FContext ctx) throws TException;

		/**
		 * Blah the server.
		 */
		public long blah(FContext ctx, int num, String Str, Event event) throws TException, AwesomeException;

}

	public static class Client implements Iface {

		private static final Object WRITE_LOCK = new Object();

		private FTransport transport;
		private FProtocolFactory protocolFactory;
		private FProtocol inputProtocol;
		private FProtocol outputProtocol;

		public Client(FTransport t, FProtocolFactory f) {
			t.setRegistry(new FClientRegistry());
			this.transport = t;
			this.protocolFactory = f;
			this.inputProtocol = f.getProtocol(t);
			this.outputProtocol = f.getProtocol(t);
		}

		/**
		 * Ping the server.
		 */
		public void ping(FContext ctx) throws TException {
			FProtocol oprot = this.outputProtocol;
			BlockingQueue<Object> result = new ArrayBlockingQueue<>(1);
			this.transport.register(ctx, recvPingHandler(ctx, result));
			try {
				synchronized (WRITE_LOCK) {
					oprot.writeRequestHeader(ctx);
					oprot.writeMessageBegin(new TMessage("ping", TMessageType.CALL, 0));
					Foo.ping_args args = new Foo.ping_args();
					args.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
				}

				Object res = null;
				try {
					res = result.take();
				} catch (InterruptedException e) {
					throw new TApplicationException(TApplicationException.INTERNAL_ERROR, "ping failed: " + e.getMessage());
				}
				if (res instanceof TException) {
					throw (TException) res;
				}
				Foo.ping_result r = (Foo.ping_result) res;
			} finally {
				this.transport.unregister(ctx);
			}
		}

		private FAsyncCallback recvPingHandler(final FContext ctx, final BlockingQueue<Object> result) {
			return new FAsyncCallback() {
				public void onMessage(TTransport tr) throws TException {
					FProtocol iprot = Client.this.protocolFactory.getProtocol(tr);
					try {
						iprot.readResponseHeader(ctx);
						TMessage message = iprot.readMessageBegin();
						if (!message.name.equals("ping")) {
							throw new TApplicationException(TApplicationException.WRONG_METHOD_NAME, "ping failed: wrong method name");
						}
						if (message.type == TMessageType.EXCEPTION) {
							TApplicationException e = TApplicationException.read(iprot);
							iprot.readMessageEnd();
							throw e;
						}
						if (message.type != TMessageType.REPLY) {
							throw new TApplicationException(TApplicationException.INVALID_MESSAGE_TYPE, "ping failed: invalid message type");
						}
						Foo.ping_result res = new Foo.ping_result();
						res.read(iprot);
						iprot.readMessageEnd();
						try {
							result.put(res);
						} catch (InterruptedException e) {
							throw new TApplicationException(TApplicationException.INTERNAL_ERROR, "ping failed: " + e.getMessage());
						}
					} catch (TException e) {
						try {
							result.put(e);
						} finally {
							throw e;
						}
					}
				}
			};
		}

		/**
		 * Blah the server.
		 */
		public long blah(FContext ctx, int num, String Str, Event event) throws TException, AwesomeException {
			FProtocol oprot = this.outputProtocol;
			BlockingQueue<Object> result = new ArrayBlockingQueue<>(1);
			this.transport.register(ctx, recvBlahHandler(ctx, result));
			try {
				synchronized (WRITE_LOCK) {
					oprot.writeRequestHeader(ctx);
					oprot.writeMessageBegin(new TMessage("blah", TMessageType.CALL, 0));
					Foo.blah_args args = new Foo.blah_args();
					args.setNum(num);
					args.setStr(Str);
					args.setEvent(event);
					args.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
				}

				Object res = null;
				try {
					res = result.take();
				} catch (InterruptedException e) {
					throw new TApplicationException(TApplicationException.INTERNAL_ERROR, "blah failed: " + e.getMessage());
				}
				if (res instanceof TException) {
					throw (TException) res;
				}
				Foo.blah_result r = (Foo.blah_result) res;
				if (r.isSetSuccess()) {
					return r.success;
				}
				if (r.awe != null) {
					throw r.awe;
				}
				throw new TApplicationException(TApplicationException.MISSING_RESULT, "blah failed: unknown result");
			} finally {
				this.transport.unregister(ctx);
			}
		}

		private FAsyncCallback recvBlahHandler(final FContext ctx, final BlockingQueue<Object> result) {
			return new FAsyncCallback() {
				public void onMessage(TTransport tr) throws TException {
					FProtocol iprot = Client.this.protocolFactory.getProtocol(tr);
					try {
						iprot.readResponseHeader(ctx);
						TMessage message = iprot.readMessageBegin();
						if (!message.name.equals("blah")) {
							throw new TApplicationException(TApplicationException.WRONG_METHOD_NAME, "blah failed: wrong method name");
						}
						if (message.type == TMessageType.EXCEPTION) {
							TApplicationException e = TApplicationException.read(iprot);
							iprot.readMessageEnd();
							throw e;
						}
						if (message.type != TMessageType.REPLY) {
							throw new TApplicationException(TApplicationException.INVALID_MESSAGE_TYPE, "blah failed: invalid message type");
						}
						Foo.blah_result res = new Foo.blah_result();
						res.read(iprot);
						iprot.readMessageEnd();
						try {
							result.put(res);
						} catch (InterruptedException e) {
							throw new TApplicationException(TApplicationException.INTERNAL_ERROR, "blah failed: " + e.getMessage());
						}
					} catch (TException e) {
						try {
							result.put(e);
						} finally {
							throw e;
						}
					}
				}
			};
		}

	}

	public static class Processor implements FProcessor {

		private static final Object WRITE_LOCK = new Object();

		private Map<String, FProcessorFunction> processorMap = new HashMap<>();

		public Processor(Iface handler) {
			this.processorMap.put("ping", new Ping(handler));
			this.processorMap.put("blah", new Blah(handler));
		}

		public void process(FProtocol iprot, FProtocol oprot) throws TException {
			FContext ctx = iprot.readRequestHeader();
			TMessage message = iprot.readMessageBegin();
			FProcessorFunction processor = this.processorMap.get(message.name);
			if (processor != null) {
				processor.process(ctx, iprot, oprot);
				return;
			}
			TProtocolUtil.skip(iprot, TType.STRUCT);
			iprot.readMessageEnd();
			TApplicationException e = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Unknown function " + message.name);
			synchronized (WRITE_LOCK) {
				oprot.writeResponseHeader(ctx);
				oprot.writeMessageBegin(new TMessage(message.name, TMessageType.EXCEPTION, 0));
				e.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}
			throw e;
		}

		private static class Ping implements FProcessorFunction {

			private Iface handler;

			public Ping(Iface handler) {
				this.handler = handler;
			}

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				Foo.ping_args args = new Foo.ping_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
					synchronized (WRITE_LOCK) {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("ping", TMessageType.EXCEPTION, 0));
						x.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					}
					throw x;
				}

				iprot.readMessageEnd();
				Foo.ping_result result = new Foo.ping_result();
				try {
					this.handler.ping(ctx);
				} catch (TException e) {
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing ping: " + e.getMessage());
					synchronized (WRITE_LOCK) {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("ping", TMessageType.EXCEPTION, 0));
						x.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("ping", TMessageType.REPLY, 0));
					result.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
				}
			}
		}

		private static class Blah implements FProcessorFunction {

			private Iface handler;

			public Blah(Iface handler) {
				this.handler = handler;
			}

			public void process(FContext ctx, FProtocol iprot, FProtocol oprot) throws TException {
				Foo.blah_args args = new Foo.blah_args();
				try {
					args.read(iprot);
				} catch (TException e) {
					iprot.readMessageEnd();
					TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
					synchronized (WRITE_LOCK) {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("blah", TMessageType.EXCEPTION, 0));
						x.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					}
					throw x;
				}

				iprot.readMessageEnd();
				Foo.blah_result result = new Foo.blah_result();
				try {
					result.success = this.handler.blah(ctx, args.num, args.Str, args.event);
					result.setSuccessIsSet(true);
				} catch (AwesomeException awe) {
					result.awe = awe;
				} catch (TException e) {
					TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing blah: " + e.getMessage());
					synchronized (WRITE_LOCK) {
						oprot.writeResponseHeader(ctx);
						oprot.writeMessageBegin(new TMessage("blah", TMessageType.EXCEPTION, 0));
						x.write(oprot);
						oprot.writeMessageEnd();
						oprot.getTransport().flush();
					}
					throw e;
				}
				synchronized (WRITE_LOCK) {
					oprot.writeResponseHeader(ctx);
					oprot.writeMessageBegin(new TMessage("blah", TMessageType.REPLY, 0));
					result.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
				}
			}
		}

	}

}